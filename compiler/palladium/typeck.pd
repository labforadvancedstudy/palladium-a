// Palladium Self-Hosting Compiler - Type Checking Module
// Type inference and checking for the Palladium language

// ============ Type Context ============

struct TypeContext {
    // Symbol table for variables
    var_names: [String; 1000],
    var_types: [Type; 1000],
    var_count: i64,
    
    // Function signatures
    fn_names: [String; 100],
    fn_types: [Type; 100],
    fn_count: i64,
    
    // Type definitions
    type_names: [String; 100],
    type_defs: [Type; 100],
    type_count: i64,
    
    // Error tracking
    errors: [String; 100],
    error_count: i64,
    
    // Current function return type
    current_return_type: Type,
}

// ============ Type Context Creation ============

fn create_type_context() -> TypeContext {
    let mut ctx = TypeContext {
        var_names: [""; 1000],
        var_types: [Type{}; 1000],
        var_count: 0,
        fn_names: [""; 100],
        fn_types: [Type{}; 100],
        fn_count: 0,
        type_names: [""; 100],
        type_defs: [Type{}; 100],
        type_count: 0,
        errors: [""; 100],
        error_count: 0,
        current_return_type: Type{},
    };
    
    // Add built-in functions
    add_builtin_functions(&mut ctx);
    
    return ctx;
}

fn add_builtin_functions(ctx: &mut TypeContext) {
    // print function
    add_function(ctx, "print", create_fn_type(
        [create_primitive_type(PRIM_STRING); 1], 1,
        create_primitive_type(PRIM_UNIT)
    ));
    
    // print_int function
    add_function(ctx, "print_int", create_fn_type(
        [create_primitive_type(PRIM_I64); 1], 1,
        create_primitive_type(PRIM_UNIT)
    ));
    
    // string_len function
    add_function(ctx, "string_len", create_fn_type(
        [create_primitive_type(PRIM_STRING); 1], 1,
        create_primitive_type(PRIM_I64)
    ));
    
    // string_concat function
    add_function(ctx, "string_concat", create_fn_type(
        [create_primitive_type(PRIM_STRING), create_primitive_type(PRIM_STRING); 2], 2,
        create_primitive_type(PRIM_STRING)
    ));
    
    // string_char_at function
    add_function(ctx, "string_char_at", create_fn_type(
        [create_primitive_type(PRIM_STRING), create_primitive_type(PRIM_I64); 2], 2,
        create_primitive_type(PRIM_I64)
    ));
    
    // string_from_char function
    add_function(ctx, "string_from_char", create_fn_type(
        [create_primitive_type(PRIM_I64); 1], 1,
        create_primitive_type(PRIM_STRING)
    ));
    
    // int_to_string function
    add_function(ctx, "int_to_string", create_fn_type(
        [create_primitive_type(PRIM_I64); 1], 1,
        create_primitive_type(PRIM_STRING)
    ));
}

fn create_fn_type(params: [Type; 10], param_count: i64, return_type: Type) -> Type {
    return Type {
        kind: TYPE_KIND_FUNCTION,
        primitive: 0,
        element_type: Type{},
        array_size: 0,
        pointee_type: Type{},
        is_mutable: false,
        param_types: params,
        param_count: param_count,
        return_type: return_type,
        name: "",
        type_param_index: 0,
    };
}

// ============ Symbol Table Operations ============

fn add_variable(ctx: &mut TypeContext, name: String, ty: Type) {
    if ctx.var_count < 1000 {
        ctx.var_names[ctx.var_count] = name;
        ctx.var_types[ctx.var_count] = ty;
        ctx.var_count = ctx.var_count + 1;
    }
}

fn add_function(ctx: &mut TypeContext, name: String, ty: Type) {
    if ctx.fn_count < 100 {
        ctx.fn_names[ctx.fn_count] = name;
        ctx.fn_types[ctx.fn_count] = ty;
        ctx.fn_count = ctx.fn_count + 1;
    }
}

fn add_type(ctx: &mut TypeContext, name: String, ty: Type) {
    if ctx.type_count < 100 {
        ctx.type_names[ctx.type_count] = name;
        ctx.type_defs[ctx.type_count] = ty;
        ctx.type_count = ctx.type_count + 1;
    }
}

fn lookup_variable(ctx: &TypeContext, name: String) -> Type {
    let mut i = ctx.var_count - 1;
    while i >= 0 {
        if string_eq(ctx.var_names[i], name) {
            return ctx.var_types[i];
        }
        i = i - 1;
    }
    return Type{}; // Not found
}

fn lookup_function(ctx: &TypeContext, name: String) -> Type {
    let mut i = 0;
    while i < ctx.fn_count {
        if string_eq(ctx.fn_names[i], name) {
            return ctx.fn_types[i];
        }
        i = i + 1;
    }
    return Type{}; // Not found
}

fn lookup_type(ctx: &TypeContext, name: String) -> Type {
    let mut i = 0;
    while i < ctx.type_count {
        if string_eq(ctx.type_names[i], name) {
            return ctx.type_defs[i];
        }
        i = i + 1;
    }
    return Type{}; // Not found
}

// ============ Error Handling ============

fn add_type_error(ctx: &mut TypeContext, message: String) {
    if ctx.error_count < 100 {
        ctx.errors[ctx.error_count] = message;
        ctx.error_count = ctx.error_count + 1;
    }
}

// ============ Type Checking ============

fn typecheck_program(ctx: &mut TypeContext, program: &mut Program) {
    let mut i = 0;
    while i < program.item_count {
        typecheck_item(ctx, &mut program.items[i]);
        i = i + 1;
    }
}

fn typecheck_item(ctx: &mut TypeContext, item: &mut Item) {
    if item.kind == ITEM_FUNCTION {
        typecheck_function(ctx, item);
    } else if item.kind == ITEM_STRUCT {
        typecheck_struct(ctx, item);
    } else if item.kind == ITEM_ENUM {
        typecheck_enum(ctx, item);
    } else if item.kind == ITEM_CONST {
        typecheck_const(ctx, item);
    } else if item.kind == ITEM_STATIC {
        typecheck_static(ctx, item);
    }
    // TODO: Handle other item types
}

fn typecheck_function(ctx: &mut TypeContext, item: &mut Item) {
    // Create function type
    let mut param_types = [Type{}; 10];
    let mut i = 0;
    while i < item.fn_param_count {
        param_types[i] = item.fn_params[i].param_type;
        i = i + 1;
    }
    
    let fn_type = create_fn_type(param_types, item.fn_param_count, item.fn_return_type);
    add_function(ctx, item.name, fn_type);
    
    // Save current context
    let old_var_count = ctx.var_count;
    let old_return_type = ctx.current_return_type;
    ctx.current_return_type = item.fn_return_type;
    
    // Add parameters to scope
    i = 0;
    while i < item.fn_param_count {
        let param = item.fn_params[i];
        if param.pattern.kind == PAT_IDENT {
            add_variable(ctx, param.pattern.name, param.param_type);
        }
        i = i + 1;
    }
    
    // Type check body
    let body_type = typecheck_expr(ctx, &mut item.fn_body);
    
    // Check return type matches
    if !types_equal(body_type, item.fn_return_type) {
        add_type_error(ctx, string_concat(
            string_concat("Function '", item.name),
            "' body type doesn't match return type"
        ));
    }
    
    // Restore context
    ctx.var_count = old_var_count;
    ctx.current_return_type = old_return_type;
}

fn typecheck_struct(ctx: &mut TypeContext, item: &mut Item) {
    // Add struct type to context
    let struct_type = Type {
        kind: TYPE_KIND_STRUCT,
        primitive: 0,
        element_type: Type{},
        array_size: 0,
        pointee_type: Type{},
        is_mutable: false,
        param_types: [Type{}; 10],
        param_count: 0,
        return_type: Type{},
        name: item.name,
        type_param_index: 0,
    };
    add_type(ctx, item.name, struct_type);
}

fn typecheck_enum(ctx: &mut TypeContext, item: &mut Item) {
    // Add enum type to context
    let enum_type = Type {
        kind: TYPE_KIND_ENUM,
        primitive: 0,
        element_type: Type{},
        array_size: 0,
        pointee_type: Type{},
        is_mutable: false,
        param_types: [Type{}; 10],
        param_count: 0,
        return_type: Type{},
        name: item.name,
        type_param_index: 0,
    };
    add_type(ctx, item.name, enum_type);
}

fn typecheck_const(ctx: &mut TypeContext, item: &mut Item) {
    let value_type = typecheck_expr(ctx, &mut item.const_value);
    if !types_equal(value_type, item.const_type) {
        add_type_error(ctx, string_concat(
            string_concat("Const '", item.name),
            "' value type doesn't match declared type"
        ));
    }
}

fn typecheck_static(ctx: &mut TypeContext, item: &mut Item) {
    let value_type = typecheck_expr(ctx, &mut item.const_value);
    if !types_equal(value_type, item.const_type) {
        add_type_error(ctx, string_concat(
            string_concat("Static '", item.name),
            "' value type doesn't match declared type"
        ));
    }
}

// ============ Expression Type Checking ============

fn typecheck_expr(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    if expr.kind == EXPR_LITERAL {
        return typecheck_literal(ctx, expr);
    } else if expr.kind == EXPR_IDENT {
        return typecheck_ident(ctx, expr);
    } else if expr.kind == EXPR_BINARY {
        return typecheck_binary(ctx, expr);
    } else if expr.kind == EXPR_UNARY {
        return typecheck_unary(ctx, expr);
    } else if expr.kind == EXPR_CALL {
        return typecheck_call(ctx, expr);
    } else if expr.kind == EXPR_FIELD {
        return typecheck_field(ctx, expr);
    } else if expr.kind == EXPR_INDEX {
        return typecheck_index(ctx, expr);
    } else if expr.kind == EXPR_ARRAY {
        return typecheck_array(ctx, expr);
    } else if expr.kind == EXPR_STRUCT {
        return typecheck_struct_expr(ctx, expr);
    } else if expr.kind == EXPR_IF {
        return typecheck_if(ctx, expr);
    } else if expr.kind == EXPR_MATCH {
        return typecheck_match(ctx, expr);
    } else if expr.kind == EXPR_BLOCK {
        return typecheck_block(ctx, expr);
    } else if expr.kind == EXPR_ASSIGN {
        return typecheck_assign(ctx, expr);
    } else if expr.kind == EXPR_RETURN {
        return typecheck_return(ctx, expr);
    } else if expr.kind == EXPR_BREAK {
        return typecheck_break(ctx, expr);
    } else if expr.kind == EXPR_CONTINUE {
        return create_primitive_type(PRIM_UNIT);
    } else if expr.kind == EXPR_WHILE {
        return typecheck_while(ctx, expr);
    } else if expr.kind == EXPR_FOR {
        return typecheck_for(ctx, expr);
    } else if expr.kind == EXPR_REFERENCE {
        return typecheck_reference(ctx, expr);
    } else if expr.kind == EXPR_DEREF {
        return typecheck_deref(ctx, expr);
    }
    
    add_type_error(ctx, "Unknown expression type");
    return Type{};
}

fn typecheck_literal(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    if expr.literal_kind == LIT_INT {
        expr.expr_type = create_primitive_type(PRIM_I64);
    } else if expr.literal_kind == LIT_FLOAT {
        expr.expr_type = create_primitive_type(PRIM_F64);
    } else if expr.literal_kind == LIT_BOOL {
        expr.expr_type = create_primitive_type(PRIM_BOOL);
    } else if expr.literal_kind == LIT_CHAR {
        expr.expr_type = create_primitive_type(PRIM_CHAR);
    } else if expr.literal_kind == LIT_STRING {
        expr.expr_type = create_primitive_type(PRIM_STRING);
    }
    return expr.expr_type;
}

fn typecheck_ident(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    // Look up variable
    let var_type = lookup_variable(ctx, expr.name);
    if var_type.kind != 0 {
        expr.expr_type = var_type;
        return var_type;
    }
    
    // Look up function
    let fn_type = lookup_function(ctx, expr.name);
    if fn_type.kind != 0 {
        expr.expr_type = fn_type;
        return fn_type;
    }
    
    add_type_error(ctx, string_concat("Unknown identifier: ", expr.name));
    return Type{};
}

fn typecheck_binary(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let left_type = typecheck_expr(ctx, &mut expr.left);
    let right_type = typecheck_expr(ctx, &mut expr.right);
    
    // Arithmetic operators
    if expr.binop == BINOP_ADD || expr.binop == BINOP_SUB || 
       expr.binop == BINOP_MUL || expr.binop == BINOP_DIV || 
       expr.binop == BINOP_REM {
        if is_numeric_type(left_type) && types_equal(left_type, right_type) {
            expr.expr_type = left_type;
            return left_type;
        } else if is_string_type(left_type) && is_string_type(right_type) && expr.binop == BINOP_ADD {
            // String concatenation
            expr.expr_type = create_primitive_type(PRIM_STRING);
            return expr.expr_type;
        } else {
            add_type_error(ctx, "Invalid types for arithmetic operator");
            return Type{};
        }
    }
    
    // Comparison operators
    if expr.binop == BINOP_EQ || expr.binop == BINOP_NE ||
       expr.binop == BINOP_LT || expr.binop == BINOP_GT ||
       expr.binop == BINOP_LE || expr.binop == BINOP_GE {
        if types_equal(left_type, right_type) {
            expr.expr_type = create_primitive_type(PRIM_BOOL);
            return expr.expr_type;
        } else {
            add_type_error(ctx, "Cannot compare different types");
            return Type{};
        }
    }
    
    // Logical operators
    if expr.binop == BINOP_LOGICAL_AND || expr.binop == BINOP_LOGICAL_OR {
        if is_bool_type(left_type) && is_bool_type(right_type) {
            expr.expr_type = create_primitive_type(PRIM_BOOL);
            return expr.expr_type;
        } else {
            add_type_error(ctx, "Logical operators require bool types");
            return Type{};
        }
    }
    
    // Bitwise operators
    if expr.binop == BINOP_AND || expr.binop == BINOP_OR || 
       expr.binop == BINOP_XOR || expr.binop == BINOP_SHL || 
       expr.binop == BINOP_SHR {
        if is_integer_type(left_type) && types_equal(left_type, right_type) {
            expr.expr_type = left_type;
            return left_type;
        } else {
            add_type_error(ctx, "Bitwise operators require integer types");
            return Type{};
        }
    }
    
    add_type_error(ctx, "Unknown binary operator");
    return Type{};
}

fn typecheck_unary(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let operand_type = typecheck_expr(ctx, &mut expr.operand);
    
    if expr.unop == UNOP_NEG {
        if is_numeric_type(operand_type) {
            expr.expr_type = operand_type;
            return operand_type;
        } else {
            add_type_error(ctx, "Negation requires numeric type");
            return Type{};
        }
    }
    
    if expr.unop == UNOP_NOT {
        if is_bool_type(operand_type) {
            expr.expr_type = create_primitive_type(PRIM_BOOL);
            return expr.expr_type;
        } else {
            add_type_error(ctx, "Logical not requires bool type");
            return Type{};
        }
    }
    
    if expr.unop == UNOP_BITNOT {
        if is_integer_type(operand_type) {
            expr.expr_type = operand_type;
            return operand_type;
        } else {
            add_type_error(ctx, "Bitwise not requires integer type");
            return Type{};
        }
    }
    
    if expr.unop == UNOP_DEREF {
        if operand_type.kind == TYPE_KIND_POINTER || operand_type.kind == TYPE_KIND_REFERENCE {
            expr.expr_type = operand_type.pointee_type;
            return expr.expr_type;
        } else {
            add_type_error(ctx, "Cannot dereference non-pointer type");
            return Type{};
        }
    }
    
    add_type_error(ctx, "Unknown unary operator");
    return Type{};
}

fn typecheck_call(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let callee_type = typecheck_expr(ctx, &mut expr.callee);
    
    if callee_type.kind != TYPE_KIND_FUNCTION {
        add_type_error(ctx, "Cannot call non-function type");
        return Type{};
    }
    
    // Check argument count
    if expr.arg_count != callee_type.param_count {
        add_type_error(ctx, "Wrong number of arguments");
        return Type{};
    }
    
    // Check argument types
    let mut i = 0;
    while i < expr.arg_count {
        let arg_type = typecheck_expr(ctx, &mut expr.args[i]);
        if !types_equal(arg_type, callee_type.param_types[i]) {
            add_type_error(ctx, string_concat("Argument type mismatch at position ", int_to_string(i)));
        }
        i = i + 1;
    }
    
    expr.expr_type = callee_type.return_type;
    return expr.expr_type;
}

fn typecheck_if(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let cond_type = typecheck_expr(ctx, &mut expr.condition);
    if !is_bool_type(cond_type) {
        add_type_error(ctx, "If condition must be bool");
    }
    
    let then_type = typecheck_expr(ctx, &mut expr.then_expr);
    
    if expr.else_expr.kind != 0 {
        let else_type = typecheck_expr(ctx, &mut expr.else_expr);
        if !types_equal(then_type, else_type) {
            add_type_error(ctx, "If branches must have same type");
            return Type{};
        }
    } else {
        // No else branch, if expression has unit type
        if !is_unit_type(then_type) {
            add_type_error(ctx, "If without else must have unit type");
        }
        expr.expr_type = create_primitive_type(PRIM_UNIT);
        return expr.expr_type;
    }
    
    expr.expr_type = then_type;
    return expr.expr_type;
}

fn typecheck_block(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    // Save variable count
    let old_var_count = ctx.var_count;
    
    // Type check statements
    let mut i = 0;
    while i < expr.stmt_count {
        typecheck_stmt(ctx, &mut expr.stmts[i]);
        i = i + 1;
    }
    
    // Type check final expression
    let block_type = if expr.final_expr.kind != 0 {
        typecheck_expr(ctx, &mut expr.final_expr)
    } else {
        create_primitive_type(PRIM_UNIT)
    };
    
    // Restore variable count
    ctx.var_count = old_var_count;
    
    expr.expr_type = block_type;
    return block_type;
}

fn typecheck_stmt(ctx: &mut TypeContext, stmt: &mut Stmt) {
    if stmt.kind == STMT_LET {
        typecheck_let_stmt(ctx, stmt);
    } else if stmt.kind == STMT_EXPR || stmt.kind == STMT_SEMI {
        typecheck_expr(ctx, &mut stmt.expr);
    }
}

fn typecheck_let_stmt(ctx: &mut TypeContext, stmt: &mut Stmt) {
    let init_type = if stmt.init_expr.kind != 0 {
        typecheck_expr(ctx, &mut stmt.init_expr)
    } else {
        Type{}
    };
    
    let var_type = if stmt.let_type.kind != 0 {
        // Has type annotation
        if init_type.kind != 0 && !types_equal(stmt.let_type, init_type) {
            add_type_error(ctx, "Let binding type mismatch");
        }
        stmt.let_type
    } else if init_type.kind != 0 {
        // Infer from initializer
        init_type
    } else {
        add_type_error(ctx, "Cannot infer type for let binding");
        Type{}
    };
    
    // Add variable to context
    if stmt.pattern.kind == PAT_IDENT {
        add_variable(ctx, stmt.pattern.name, var_type);
    }
}

// More type checking functions...

fn typecheck_assign(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let left_type = typecheck_expr(ctx, &mut expr.left);
    let right_type = typecheck_expr(ctx, &mut expr.right);
    
    if !types_equal(left_type, right_type) {
        add_type_error(ctx, "Assignment type mismatch");
    }
    
    expr.expr_type = create_primitive_type(PRIM_UNIT);
    return expr.expr_type;
}

fn typecheck_return(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let value_type = if expr.operand.kind != 0 {
        typecheck_expr(ctx, &mut expr.operand)
    } else {
        create_primitive_type(PRIM_UNIT)
    };
    
    if !types_equal(value_type, ctx.current_return_type) {
        add_type_error(ctx, "Return type mismatch");
    }
    
    // Return expressions have never type
    expr.expr_type = Type { kind: TYPE_KIND_PRIMITIVE, primitive: 0, element_type: Type{}, array_size: 0, pointee_type: Type{}, is_mutable: false, param_types: [Type{}; 10], param_count: 0, return_type: Type{}, name: "!", type_param_index: 0 };
    return expr.expr_type;
}

// Stub implementations for remaining type checkers
fn typecheck_field(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let base_type = typecheck_expr(ctx, &mut expr.base);
    
    if base_type.kind == TYPE_KIND_STRUCT {
        // TODO: Look up field in struct definition
        // For now, just return a placeholder type
        expr.expr_type = Type{};
        return expr.expr_type;
    } else {
        add_type_error(ctx, "Field access requires struct type");
        return Type{};
    }
}

fn typecheck_index(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let array_type = typecheck_expr(ctx, &mut expr.array);
    let index_type = typecheck_expr(ctx, &mut expr.index);
    
    if !is_integer_type(index_type) {
        add_type_error(ctx, "Array index must be integer");
    }
    
    if array_type.kind == TYPE_KIND_ARRAY {
        expr.expr_type = array_type.element_type;
        return expr.expr_type;
    } else {
        add_type_error(ctx, "Cannot index non-array type");
        return Type{};
    }
}

fn typecheck_array(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    if expr.element_count == 0 {
        add_type_error(ctx, "Cannot infer type of empty array");
        return Type{};
    }
    
    let elem_type = typecheck_expr(ctx, &mut expr.elements[0]);
    
    // Check all elements have same type
    let mut i = 1;
    while i < expr.element_count {
        let t = typecheck_expr(ctx, &mut expr.elements[i]);
        if !types_equal(t, elem_type) {
            add_type_error(ctx, "Array elements must have same type");
        }
        i = i + 1;
    }
    
    expr.expr_type = create_array_type(elem_type, expr.element_count);
    return expr.expr_type;
}

fn typecheck_struct_expr(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    // Look up struct type
    let struct_type = lookup_type(ctx, expr.struct_name);
    if struct_type.kind == 0 {
        add_type_error(ctx, string_concat("Unknown struct: ", expr.struct_name));
        return Type{};
    }
    
    if struct_type.kind != TYPE_KIND_STRUCT {
        add_type_error(ctx, string_concat(expr.struct_name, " is not a struct"));
        return Type{};
    }
    
    // TODO: Check field types match
    
    expr.expr_type = struct_type;
    return struct_type;
}

fn typecheck_match(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    // Type check the match scrutinee
    let scrutinee_type = typecheck_expr(ctx, &mut expr.match_expr);
    
    if expr.arm_count == 0 {
        add_type_error(ctx, "Match expression must have at least one arm");
        return Type{};
    }
    
    // Type check first arm to determine result type
    let result_type = typecheck_match_arm(ctx, &mut expr.arms[0], scrutinee_type);
    
    // Check remaining arms have same result type
    let mut i = 1;
    while i < expr.arm_count {
        let arm_type = typecheck_match_arm(ctx, &mut expr.arms[i], scrutinee_type);
        if !types_equal(arm_type, result_type) {
            add_type_error(ctx, "All match arms must have same type");
        }
        i = i + 1;
    }
    
    // TODO: Check exhaustiveness
    
    expr.expr_type = result_type;
    return result_type;
}

fn typecheck_match_arm(ctx: &mut TypeContext, arm: &mut MatchArm, scrutinee_type: Type) -> Type {
    // Save variable count for pattern bindings
    let old_var_count = ctx.var_count;
    
    // Type check pattern against scrutinee type
    typecheck_pattern(ctx, &mut arm.pattern, scrutinee_type);
    
    // Type check guard if present
    if arm.guard.kind != 0 {
        let guard_type = typecheck_expr(ctx, &mut arm.guard);
        if !is_bool_type(guard_type) {
            add_type_error(ctx, "Match guard must be bool");
        }
    }
    
    // Type check body
    let body_type = typecheck_expr(ctx, &mut arm.body);
    
    // Restore variable count
    ctx.var_count = old_var_count;
    
    return body_type;
}

fn typecheck_pattern(ctx: &mut TypeContext, pat: &mut Pattern, expected_type: Type) {
    if pat.kind == PAT_WILDCARD {
        // Wildcard matches anything
        return;
    } else if pat.kind == PAT_IDENT {
        // Bind variable with expected type
        add_variable(ctx, pat.name, expected_type);
    } else if pat.kind == PAT_LITERAL {
        // Check literal type matches expected
        // TODO: Implement literal pattern checking
    } else if pat.kind == PAT_TUPLE {
        // TODO: Implement tuple pattern checking
    } else if pat.kind == PAT_STRUCT {
        // TODO: Implement struct pattern checking
    } else if pat.kind == PAT_ENUM {
        // Check enum pattern
        if expected_type.kind != TYPE_KIND_ENUM {
            add_type_error(ctx, "Enum pattern used on non-enum type");
            return;
        }
        
        // TODO: Check variant exists in enum
        // TODO: Check variant field patterns
    }
}

fn typecheck_break(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    if expr.operand.kind != 0 {
        let value_type = typecheck_expr(ctx, &mut expr.operand);
        // TODO: Check against loop type
    }
    
    // Break expressions have never type
    expr.expr_type = Type { kind: TYPE_KIND_PRIMITIVE, primitive: 0, element_type: Type{}, array_size: 0, pointee_type: Type{}, is_mutable: false, param_types: [Type{}; 10], param_count: 0, return_type: Type{}, name: "!", type_param_index: 0 };
    return expr.expr_type;
}

fn typecheck_while(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let cond_type = typecheck_expr(ctx, &mut expr.condition);
    if !is_bool_type(cond_type) {
        add_type_error(ctx, "While condition must be bool");
    }
    
    typecheck_expr(ctx, &mut expr.body);
    
    expr.expr_type = create_primitive_type(PRIM_UNIT);
    return expr.expr_type;
}

fn typecheck_for(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    // Save variable count
    let old_var_count = ctx.var_count;
    
    // Type check iterator expression
    let iter_type = typecheck_expr(ctx, &mut expr.iterator);
    
    // TODO: Check iter_type implements Iterator trait
    // For now, assume it yields the element type directly
    
    // Add loop variable to scope
    if expr.for_pattern.kind == PAT_IDENT {
        // TODO: Determine actual element type from iterator
        add_variable(ctx, expr.for_pattern.name, Type{});
    }
    
    // Type check body
    typecheck_expr(ctx, &mut expr.body);
    
    // Restore variable count
    ctx.var_count = old_var_count;
    
    expr.expr_type = create_primitive_type(PRIM_UNIT);
    return expr.expr_type;
}

fn typecheck_reference(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    let inner_type = typecheck_expr(ctx, &mut expr.ref_expr);
    
    expr.expr_type = Type {
        kind: TYPE_KIND_REFERENCE,
        primitive: 0,
        element_type: inner_type,
        array_size: 0,
        pointee_type: inner_type,
        is_mutable: expr.is_mut_ref,
        param_types: [Type{}; 10],
        param_count: 0,
        return_type: Type{},
        name: "",
        type_param_index: 0,
    };
    
    return expr.expr_type;
}

fn typecheck_deref(ctx: &mut TypeContext, expr: &mut Expr) -> Type {
    return typecheck_unary(ctx, expr);
}

// ============ Type Utilities ============

fn types_equal(a: Type, b: Type) -> bool {
    if a.kind != b.kind {
        return false;
    }
    
    if a.kind == TYPE_KIND_PRIMITIVE {
        return a.primitive == b.primitive;
    }
    
    if a.kind == TYPE_KIND_ARRAY {
        return types_equal(a.element_type, b.element_type) && a.array_size == b.array_size;
    }
    
    if a.kind == TYPE_KIND_REFERENCE || a.kind == TYPE_KIND_POINTER {
        return types_equal(a.pointee_type, b.pointee_type) && a.is_mutable == b.is_mutable;
    }
    
    if a.kind == TYPE_KIND_FUNCTION {
        if a.param_count != b.param_count {
            return false;
        }
        
        let mut i = 0;
        while i < a.param_count {
            if !types_equal(a.param_types[i], b.param_types[i]) {
                return false;
            }
            i = i + 1;
        }
        
        return types_equal(a.return_type, b.return_type);
    }
    
    if a.kind == TYPE_KIND_STRUCT || a.kind == TYPE_KIND_ENUM {
        return string_eq(a.name, b.name);
    }
    
    return false;
}

fn is_numeric_type(ty: Type) -> bool {
    if ty.kind != TYPE_KIND_PRIMITIVE {
        return false;
    }
    return is_integer_type(ty) || is_float_type(ty);
}

fn is_integer_type(ty: Type) -> bool {
    if ty.kind != TYPE_KIND_PRIMITIVE {
        return false;
    }
    return ty.primitive >= PRIM_I8 && ty.primitive <= PRIM_U128;
}

fn is_float_type(ty: Type) -> bool {
    if ty.kind != TYPE_KIND_PRIMITIVE {
        return false;
    }
    return ty.primitive == PRIM_F32 || ty.primitive == PRIM_F64;
}

fn is_bool_type(ty: Type) -> bool {
    return ty.kind == TYPE_KIND_PRIMITIVE && ty.primitive == PRIM_BOOL;
}

fn is_string_type(ty: Type) -> bool {
    return ty.kind == TYPE_KIND_PRIMITIVE && ty.primitive == PRIM_STRING;
}

fn is_unit_type(ty: Type) -> bool {
    return ty.kind == TYPE_KIND_PRIMITIVE && ty.primitive == PRIM_UNIT;
}

// ============ Test Function ============

fn test_typechecker() {
    let input = "fn main() {
    let x = 42;
    let y = x + 10;
    let msg = \"Result: \";
    print(string_concat(msg, int_to_string(y)));
}";

    // First tokenize
    let mut lexer = create_lexer(input);
    
    // Then parse
    let mut parser = create_parser(lexer.tokens, lexer.token_count);
    let mut program = parse_program(&mut parser);
    
    // Type check
    let mut ctx = create_type_context();
    typecheck_program(&mut ctx, &mut program);
    
    print("=== Type Checker Test ===");
    if ctx.error_count > 0 {
        print("Type errors:");
        let mut i = 0;
        while i < ctx.error_count {
            print(ctx.errors[i]);
            i = i + 1;
        }
    } else {
        print("Type check successful!");
    }
}