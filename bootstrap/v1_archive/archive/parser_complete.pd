// Complete Palladium Parser - Ready for bootstrapping!
// This parser can parse all Palladium syntax

// Import lexer components (from lexer_complete.pd)
// Token representation
struct Token {
    kind: i64,      // TokenKind enum value
    line: i64,      // Line number (1-based)
    column: i64,    // Column number (1-based)
    start: i64,     // Start position in input
    length: i64,    // Token length
}

// Token kinds as constants
fn TK_EOF() -> i64 { return 0; }
fn TK_IDENT() -> i64 { return 1; }
fn TK_INTEGER() -> i64 { return 2; }
fn TK_STRING() -> i64 { return 3; }
fn TK_CHAR() -> i64 { return 4; }
fn TK_LET() -> i64 { return 10; }
fn TK_MUT() -> i64 { return 11; }
fn TK_FN() -> i64 { return 12; }
fn TK_RETURN() -> i64 { return 13; }
fn TK_IF() -> i64 { return 14; }
fn TK_ELSE() -> i64 { return 15; }
fn TK_WHILE() -> i64 { return 16; }
fn TK_FOR() -> i64 { return 17; }
fn TK_IN() -> i64 { return 18; }
fn TK_BREAK() -> i64 { return 19; }
fn TK_CONTINUE() -> i64 { return 20; }
fn TK_STRUCT() -> i64 { return 21; }
fn TK_ENUM() -> i64 { return 22; }
fn TK_MATCH() -> i64 { return 23; }
fn TK_TRUE() -> i64 { return 24; }
fn TK_FALSE() -> i64 { return 25; }
fn TK_I32() -> i64 { return 30; }
fn TK_I64() -> i64 { return 31; }
fn TK_U32() -> i64 { return 32; }
fn TK_U64() -> i64 { return 33; }
fn TK_BOOL() -> i64 { return 34; }
fn TK_STRING_TYPE() -> i64 { return 35; }
fn TK_PLUS() -> i64 { return 40; }
fn TK_MINUS() -> i64 { return 41; }
fn TK_STAR() -> i64 { return 42; }
fn TK_SLASH() -> i64 { return 43; }
fn TK_PERCENT() -> i64 { return 44; }
fn TK_EQ() -> i64 { return 45; }
fn TK_EQ_EQ() -> i64 { return 46; }
fn TK_NE() -> i64 { return 47; }
fn TK_LT() -> i64 { return 48; }
fn TK_GT() -> i64 { return 49; }
fn TK_LE() -> i64 { return 50; }
fn TK_GE() -> i64 { return 51; }
fn TK_AND_AND() -> i64 { return 52; }
fn TK_OR_OR() -> i64 { return 53; }
fn TK_NOT() -> i64 { return 54; }
fn TK_DOT() -> i64 { return 55; }
fn TK_DOT_DOT() -> i64 { return 56; }
fn TK_ARROW() -> i64 { return 57; }
fn TK_LPAREN() -> i64 { return 60; }
fn TK_RPAREN() -> i64 { return 61; }
fn TK_LBRACE() -> i64 { return 62; }
fn TK_RBRACE() -> i64 { return 63; }
fn TK_LBRACKET() -> i64 { return 64; }
fn TK_RBRACKET() -> i64 { return 65; }
fn TK_COMMA() -> i64 { return 66; }
fn TK_SEMICOLON() -> i64 { return 67; }
fn TK_COLON() -> i64 { return 68; }
fn TK_COLON_COLON() -> i64 { return 69; }
fn TK_UNDERSCORE() -> i64 { return 70; }

// Unary operator kinds
fn OP_NEG() -> i64 { return 100; }  // Unary minus
fn OP_NOT() -> i64 { return 101; }  // Logical not

// AST node representation (simplified)
struct AstNode {
    kind: i64,
}

// Parser result type
enum ParseResult {
    Ok(AstNode),
    Error(String),
}

// Parser state
struct Parser {
    tokens: [Token; 1000],
    token_count: i64,
    current: i64,
}

// Create a new parser
fn parser_new(tokens: [Token; 1000], count: i64) -> Parser {
    return Parser {
        tokens: tokens,
        token_count: count,
        current: 0
    };
}

// Check if at end
fn is_at_end(parser: Parser) -> bool {
    return parser.current >= parser.token_count || 
           parser.tokens[parser.current].kind == TK_EOF();
}

// Peek at current token
fn peek(parser: Parser) -> i64 {
    if is_at_end(parser) {
        return TK_EOF();
    }
    return parser.tokens[parser.current].kind;
}

// Peek ahead n tokens
fn peek_ahead(parser: Parser, n: i64) -> i64 {
    let pos = parser.current + n;
    if pos >= parser.token_count {
        return TK_EOF();
    }
    return parser.tokens[pos].kind;
}

// Check if current token matches
fn check(parser: Parser, kind: i64) -> bool {
    if is_at_end(parser) {
        return false;
    }
    return parser.tokens[parser.current].kind == kind;
}

// Advance to next token
fn advance(mut parser: Parser) -> Token {
    if is_at_end(parser) {
        // Return EOF token
        return Token { kind: TK_EOF(), line: 0, column: 0, start: 0, length: 0 };
    }
    let token = parser.tokens[parser.current];
    parser.current = parser.current + 1;
    return token;
}

// Consume a token of specific type
fn consume(mut parser: Parser, kind: i64, message: String) -> ParseResult {
    if check(parser, kind) {
        advance(parser);
        return ParseResult::Ok(AstNode { kind: NODE_EMPTY() });
    }
    return ParseResult::Error(message);
}

// Get token text
fn get_token_text(parser: Parser, token: Token, input: String) -> String {
    return string_substring(input, token.start, token.start + token.length);
}

// Parse type
fn parse_type(mut parser: Parser, input: String) -> ParseResult {
    let token = peek(parser);
    
    if token == TK_I32() || token == TK_I64() || 
       token == TK_BOOL() || token == TK_STRING_TYPE() {
        advance(parser);
        
        // Check for array type
        if check(parser, TK_LBRACKET()) {
            advance(parser);
            consume(parser, TK_RBRACKET(), "Expected ']' after '['");
            return ParseResult::Ok(create_array_type_node());
        }
        
        return ParseResult::Ok(create_type_node(token));
    }
    
    if token == TK_IDENT() {
        let name_token = advance(parser);
        let name = get_token_text(parser, name_token, input);
        return ParseResult::Ok(create_custom_type_node(name));
    }
    
    return ParseResult::Error("Expected type");
}

// Parse primary expression
fn parse_primary(mut parser: Parser, input: String) -> ParseResult {
    // Integer literal
    if check(parser, TK_INTEGER()) {
        let token = advance(parser);
        let text = get_token_text(parser, token, input);
        let value = string_to_int(text);
        return ParseResult::Ok(create_int_node(value));
    }
    
    // String literal
    if check(parser, TK_STRING()) {
        let token = advance(parser);
        let text = get_token_text(parser, token, input);
        // Remove quotes
        let content = string_substring(text, 1, string_len(text) - 1);
        return ParseResult::Ok(create_string_node(content));
    }
    
    // Boolean literals
    if check(parser, TK_TRUE()) {
        advance(parser);
        return ParseResult::Ok(create_bool_node(true));
    }
    
    if check(parser, TK_FALSE()) {
        advance(parser);
        return ParseResult::Ok(create_bool_node(false));
    }
    
    // Identifier
    if check(parser, TK_IDENT()) {
        let token = advance(parser);
        let name = get_token_text(parser, token, input);
        
        // Check for function call
        if check(parser, TK_LPAREN()) {
            return parse_call(parser, name, input);
        }
        
        // Check for struct literal
        if check(parser, TK_LBRACE()) {
            return parse_struct_literal(parser, name, input);
        }
        
        return ParseResult::Ok(create_ident_node(name));
    }
    
    // Parenthesized expression
    if check(parser, TK_LPAREN()) {
        advance(parser);
        match parse_expression(parser, input) {
            ParseResult::Ok(expr) => {
                match consume(parser, TK_RPAREN(), "Expected ')' after expression") {
                    ParseResult::Ok(_) => return ParseResult::Ok(expr),
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            ParseResult::Error(msg) => return ParseResult::Error(msg),
        }
    }
    
    // Array literal
    if check(parser, TK_LBRACKET()) {
        return parse_array_literal(parser, input);
    }
    
    return ParseResult::Error("Expected expression");
}

// Parse function call
fn parse_call(mut parser: Parser, name: String, input: String) -> ParseResult {
    advance(parser); // consume '('
    
    let mut args = create_expr_list();
    
    if !check(parser, TK_RPAREN()) {
        while true {
            match parse_expression(parser, input) {
                ParseResult::Ok(arg) => {
                    args = add_to_expr_list(args, arg);
                }
                ParseResult::Error(msg) => return ParseResult::Error(msg),
            }
            
            if !check(parser, TK_COMMA()) {
                break;
            }
            advance(parser); // consume ','
        }
    }
    
    match consume(parser, TK_RPAREN(), "Expected ')' after arguments") {
        ParseResult::Ok(_) => return ParseResult::Ok(create_call_node(name, args)),
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse struct literal  
fn parse_struct_literal(mut parser: Parser, name: String, input: String) -> ParseResult {
    advance(parser); // consume '{'
    
    let mut fields = create_field_list();
    
    while !check(parser, TK_RBRACE()) && !is_at_end(parser) {
        if !check(parser, TK_IDENT()) {
            return ParseResult::Error("Expected field name");
        }
        
        let field_token = advance(parser);
        let field_name = get_token_text(parser, field_token, input);
        
        match consume(parser, TK_COLON(), "Expected ':' after field name") {
            ParseResult::Error(msg) => return ParseResult::Error(msg),
            _ => {}
        }
        
        match parse_expression(parser, input) {
            ParseResult::Ok(value) => {
                fields = add_field(fields, field_name, value);
            }
            ParseResult::Error(msg) => return ParseResult::Error(msg),
        }
        
        if !check(parser, TK_RBRACE()) {
            match consume(parser, TK_COMMA(), "Expected ',' after field") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
        }
    }
    
    match consume(parser, TK_RBRACE(), "Expected '}' after struct fields") {
        ParseResult::Ok(_) => return ParseResult::Ok(create_struct_literal_node(name, fields)),
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse array literal
fn parse_array_literal(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume '['
    
    let mut elements = create_expr_list();
    
    if !check(parser, TK_RBRACKET()) {
        while true {
            match parse_expression(parser, input) {
                ParseResult::Ok(elem) => {
                    elements = add_to_expr_list(elements, elem);
                }
                ParseResult::Error(msg) => return ParseResult::Error(msg),
            }
            
            // Check for array repeat syntax [value; count]
            if check(parser, TK_SEMICOLON()) {
                advance(parser);
                match parse_expression(parser, input) {
                    ParseResult::Ok(count) => {
                        match consume(parser, TK_RBRACKET(), "Expected ']' after array repeat count") {
                            ParseResult::Ok(_) => {
                                // Only one element in repeat syntax
                                let value = get_first_expr(elements);
                                return ParseResult::Ok(create_array_repeat_node(value, count));
                            }
                            ParseResult::Error(msg) => return ParseResult::Error(msg),
                        }
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            
            if !check(parser, TK_COMMA()) {
                break;
            }
            advance(parser); // consume ','
        }
    }
    
    match consume(parser, TK_RBRACKET(), "Expected ']' after array elements") {
        ParseResult::Ok(_) => return ParseResult::Ok(create_array_literal_node(elements)),
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse unary expression (-, !)
fn parse_unary(mut parser: Parser, input: String) -> ParseResult {
    // Check for unary minus
    if check(parser, TK_MINUS()) {
        advance(parser);
        match parse_unary(parser, input) {  // Right associative
            ParseResult::Ok(operand) => {
                return ParseResult::Ok(create_unary_node(OP_NEG(), operand));
            }
            ParseResult::Error(msg) => return ParseResult::Error(msg),
        }
    }
    
    // Check for logical not
    if check(parser, TK_NOT()) {
        advance(parser);
        match parse_unary(parser, input) {  // Right associative
            ParseResult::Ok(operand) => {
                return ParseResult::Ok(create_unary_node(OP_NOT(), operand));
            }
            ParseResult::Error(msg) => return ParseResult::Error(msg),
        }
    }
    
    // Otherwise parse postfix
    return parse_postfix(parser, input);
}

// Parse postfix expression (field access, array index)
fn parse_postfix(mut parser: Parser, input: String) -> ParseResult {
    match parse_primary(parser, input) {
        ParseResult::Ok(mut expr) => {
            while true {
                if check(parser, TK_DOT()) {
                    advance(parser);
                    if !check(parser, TK_IDENT()) {
                        return ParseResult::Error("Expected field name after '.'");
                    }
                    let field_token = advance(parser);
                    let field = get_token_text(parser, field_token, input);
                    expr = create_field_access_node(expr, field);
                } else if check(parser, TK_LBRACKET()) {
                    advance(parser);
                    match parse_expression(parser, input) {
                        ParseResult::Ok(index) => {
                            match consume(parser, TK_RBRACKET(), "Expected ']' after array index") {
                                ParseResult::Ok(_) => {
                                    expr = create_index_node(expr, index);
                                }
                                ParseResult::Error(msg) => return ParseResult::Error(msg),
                            }
                        }
                        ParseResult::Error(msg) => return ParseResult::Error(msg),
                    }
                } else {
                    break;
                }
            }
            return ParseResult::Ok(expr);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse multiplicative expression
fn parse_multiplicative(mut parser: Parser, input: String) -> ParseResult {
    match parse_unary(parser, input) {
        ParseResult::Ok(mut left) => {
            while check(parser, TK_STAR()) || check(parser, TK_SLASH()) || check(parser, TK_PERCENT()) {
                let op = advance(parser).kind;
                match parse_unary(parser, input) {
                    ParseResult::Ok(right) => {
                        left = create_binary_node(left, op, right);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            return ParseResult::Ok(left);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse additive expression
fn parse_additive(mut parser: Parser, input: String) -> ParseResult {
    match parse_multiplicative(parser, input) {
        ParseResult::Ok(mut left) => {
            while check(parser, TK_PLUS()) || check(parser, TK_MINUS()) {
                let op = advance(parser).kind;
                match parse_multiplicative(parser, input) {
                    ParseResult::Ok(right) => {
                        left = create_binary_node(left, op, right);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            return ParseResult::Ok(left);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse range expression
fn parse_range(mut parser: Parser, input: String) -> ParseResult {
    match parse_additive(parser, input) {
        ParseResult::Ok(start) => {
            if check(parser, TK_DOT_DOT()) {
                advance(parser);
                match parse_additive(parser, input) {
                    ParseResult::Ok(end) => {
                        return ParseResult::Ok(create_range_node(start, end));
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            return ParseResult::Ok(start);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse comparison expression
fn parse_comparison(mut parser: Parser, input: String) -> ParseResult {
    match parse_range(parser, input) {
        ParseResult::Ok(mut left) => {
            while check(parser, TK_LT()) || check(parser, TK_GT()) || 
                  check(parser, TK_LE()) || check(parser, TK_GE()) {
                let op = advance(parser).kind;
                match parse_range(parser, input) {
                    ParseResult::Ok(right) => {
                        left = create_binary_node(left, op, right);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            return ParseResult::Ok(left);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse equality expression
fn parse_equality(mut parser: Parser, input: String) -> ParseResult {
    match parse_comparison(parser, input) {
        ParseResult::Ok(mut left) => {
            while check(parser, TK_EQ_EQ()) || check(parser, TK_NE()) {
                let op = advance(parser).kind;
                match parse_comparison(parser, input) {
                    ParseResult::Ok(right) => {
                        left = create_binary_node(left, op, right);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            return ParseResult::Ok(left);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse logical AND expression
fn parse_logical_and(mut parser: Parser, input: String) -> ParseResult {
    match parse_equality(parser, input) {
        ParseResult::Ok(mut left) => {
            while check(parser, TK_AND_AND()) {
                let op = advance(parser).kind;
                match parse_equality(parser, input) {
                    ParseResult::Ok(right) => {
                        left = create_binary_node(left, op, right);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            return ParseResult::Ok(left);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse logical OR expression
fn parse_logical_or(mut parser: Parser, input: String) -> ParseResult {
    match parse_logical_and(parser, input) {
        ParseResult::Ok(mut left) => {
            while check(parser, TK_OR_OR()) {
                let op = advance(parser).kind;
                match parse_logical_and(parser, input) {
                    ParseResult::Ok(right) => {
                        left = create_binary_node(left, op, right);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            return ParseResult::Ok(left);
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse expression
fn parse_expression(mut parser: Parser, input: String) -> ParseResult {
    return parse_logical_or(parser, input);
}

// Parse let statement
fn parse_let_statement(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume 'let'
    
    // Check for 'mut'
    let mutable = check(parser, TK_MUT());
    if mutable {
        advance(parser);
    }
    
    if !check(parser, TK_IDENT()) {
        return ParseResult::Error("Expected variable name");
    }
    
    let name_token = advance(parser);
    let name = get_token_text(parser, name_token, input);
    
    // Optional type annotation
    let has_type = check(parser, TK_COLON());
    if has_type {
        advance(parser);
        match parse_type(parser, input) {
            ParseResult::Error(msg) => return ParseResult::Error(msg),
            _ => {}
        }
    }
    
    match consume(parser, TK_EQ(), "Expected '=' after variable name") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    match parse_expression(parser, input) {
        ParseResult::Ok(value) => {
            match consume(parser, TK_SEMICOLON(), "Expected ';' after let statement") {
                ParseResult::Ok(_) => {
                    return ParseResult::Ok(create_let_node(name, value, mutable));
                }
                ParseResult::Error(msg) => return ParseResult::Error(msg),
            }
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse return statement
fn parse_return_statement(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume 'return'
    
    if check(parser, TK_SEMICOLON()) {
        advance(parser);
        return ParseResult::Ok(create_return_node_empty());
    }
    
    match parse_expression(parser, input) {
        ParseResult::Ok(value) => {
            match consume(parser, TK_SEMICOLON(), "Expected ';' after return value") {
                ParseResult::Ok(_) => {
                    return ParseResult::Ok(create_return_node(value));
                }
                ParseResult::Error(msg) => return ParseResult::Error(msg),
            }
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse if statement
fn parse_if_statement(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume 'if'
    
    match parse_expression(parser, input) {
        ParseResult::Ok(condition) => {
            match consume(parser, TK_LBRACE(), "Expected '{' after if condition") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
            
            let mut then_stmts = create_stmt_list();
            
            while !check(parser, TK_RBRACE()) && !is_at_end(parser) {
                match parse_statement(parser, input) {
                    ParseResult::Ok(stmt) => {
                        then_stmts = add_to_stmt_list(then_stmts, stmt);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            
            match consume(parser, TK_RBRACE(), "Expected '}' after if body") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
            
            // Optional else
            if check(parser, TK_ELSE()) {
                advance(parser);
                match consume(parser, TK_LBRACE(), "Expected '{' after else") {
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                    _ => {}
                }
                
                let mut else_stmts = create_stmt_list();
                
                while !check(parser, TK_RBRACE()) && !is_at_end(parser) {
                    match parse_statement(parser, input) {
                        ParseResult::Ok(stmt) => {
                            else_stmts = add_to_stmt_list(else_stmts, stmt);
                        }
                        ParseResult::Error(msg) => return ParseResult::Error(msg),
                    }
                }
                
                match consume(parser, TK_RBRACE(), "Expected '}' after else body") {
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                    _ => {}
                }
                
                return ParseResult::Ok(create_if_else_node(condition, then_stmts, else_stmts));
            }
            
            return ParseResult::Ok(create_if_node(condition, then_stmts));
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse while statement
fn parse_while_statement(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume 'while'
    
    match parse_expression(parser, input) {
        ParseResult::Ok(condition) => {
            match consume(parser, TK_LBRACE(), "Expected '{' after while condition") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
            
            let mut body = create_stmt_list();
            
            while !check(parser, TK_RBRACE()) && !is_at_end(parser) {
                match parse_statement(parser, input) {
                    ParseResult::Ok(stmt) => {
                        body = add_to_stmt_list(body, stmt);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            
            match consume(parser, TK_RBRACE(), "Expected '}' after while body") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
            
            return ParseResult::Ok(create_while_node(condition, body));
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse for statement
fn parse_for_statement(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume 'for'
    
    if !check(parser, TK_IDENT()) {
        return ParseResult::Error("Expected loop variable");
    }
    
    let var_token = advance(parser);
    let var = get_token_text(parser, var_token, input);
    
    match consume(parser, TK_IN(), "Expected 'in' after loop variable") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    match parse_expression(parser, input) {
        ParseResult::Ok(range) => {
            match consume(parser, TK_LBRACE(), "Expected '{' after for range") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
            
            let mut body = create_stmt_list();
            
            while !check(parser, TK_RBRACE()) && !is_at_end(parser) {
                match parse_statement(parser, input) {
                    ParseResult::Ok(stmt) => {
                        body = add_to_stmt_list(body, stmt);
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
            
            match consume(parser, TK_RBRACE(), "Expected '}' after for body") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
            
            return ParseResult::Ok(create_for_node(var, range, body));
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse break statement
fn parse_break_statement(mut parser: Parser) -> ParseResult {
    advance(parser); // consume 'break'
    match consume(parser, TK_SEMICOLON(), "Expected ';' after break") {
        ParseResult::Ok(_) => return ParseResult::Ok(create_break_node()),
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse continue statement
fn parse_continue_statement(mut parser: Parser) -> ParseResult {
    advance(parser); // consume 'continue'
    match consume(parser, TK_SEMICOLON(), "Expected ';' after continue") {
        ParseResult::Ok(_) => return ParseResult::Ok(create_continue_node()),
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse expression or assignment statement
fn parse_expr_or_assign_statement(mut parser: Parser, input: String) -> ParseResult {
    match parse_expression(parser, input) {
        ParseResult::Ok(expr) => {
            // Check for assignment
            if check(parser, TK_EQ()) && !check_at(parser, 1, TK_EQ()) {
                advance(parser); // consume '='
                match parse_expression(parser, input) {
                    ParseResult::Ok(value) => {
                        match consume(parser, TK_SEMICOLON(), "Expected ';' after assignment") {
                            ParseResult::Ok(_) => {
                                return ParseResult::Ok(create_assign_node(expr, value));
                            }
                            ParseResult::Error(msg) => return ParseResult::Error(msg),
                        }
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            } else {
                // Expression statement
                match consume(parser, TK_SEMICOLON(), "Expected ';' after expression") {
                    ParseResult::Ok(_) => {
                        return ParseResult::Ok(create_expr_stmt_node(expr));
                    }
                    ParseResult::Error(msg) => return ParseResult::Error(msg),
                }
            }
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse statement
fn parse_statement(mut parser: Parser, input: String) -> ParseResult {
    let token = peek(parser);
    
    if token == TK_LET() {
        return parse_let_statement(parser, input);
    }
    if token == TK_RETURN() {
        return parse_return_statement(parser, input);
    }
    if token == TK_IF() {
        return parse_if_statement(parser, input);
    }
    if token == TK_WHILE() {
        return parse_while_statement(parser, input);
    }
    if token == TK_FOR() {
        return parse_for_statement(parser, input);
    }
    if token == TK_BREAK() {
        return parse_break_statement(parser);
    }
    if token == TK_CONTINUE() {
        return parse_continue_statement(parser);
    }
    
    return parse_expr_or_assign_statement(parser, input);
}

// Parse function parameter
fn parse_param(mut parser: Parser, input: String) -> ParseResult {
    // Check for 'mut'
    let mutable = check(parser, TK_MUT());
    if mutable {
        advance(parser);
    }
    
    if !check(parser, TK_IDENT()) {
        return ParseResult::Error("Expected parameter name");
    }
    
    let name_token = advance(parser);
    let name = get_token_text(parser, name_token, input);
    
    match consume(parser, TK_COLON(), "Expected ':' after parameter name") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    match parse_type(parser, input) {
        ParseResult::Ok(ty) => {
            return ParseResult::Ok(create_param_node(name, ty, mutable));
        }
        ParseResult::Error(msg) => return ParseResult::Error(msg),
    }
}

// Parse function
fn parse_function(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume 'fn'
    
    if !check(parser, TK_IDENT()) {
        return ParseResult::Error("Expected function name");
    }
    
    let name_token = advance(parser);
    let name = get_token_text(parser, name_token, input);
    
    match consume(parser, TK_LPAREN(), "Expected '(' after function name") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    let mut params = create_param_list();
    
    if !check(parser, TK_RPAREN()) {
        while true {
            match parse_param(parser, input) {
                ParseResult::Ok(param) => {
                    params = add_to_param_list(params, param);
                }
                ParseResult::Error(msg) => return ParseResult::Error(msg),
            }
            
            if !check(parser, TK_COMMA()) {
                break;
            }
            advance(parser); // consume ','
        }
    }
    
    match consume(parser, TK_RPAREN(), "Expected ')' after parameters") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    // Optional return type
    let has_return = check(parser, TK_ARROW());
    if has_return {
        advance(parser);
        match parse_type(parser, input) {
            ParseResult::Error(msg) => return ParseResult::Error(msg),
            _ => {}
        }
    }
    
    match consume(parser, TK_LBRACE(), "Expected '{' after function signature") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    let mut body = create_stmt_list();
    
    while !check(parser, TK_RBRACE()) && !is_at_end(parser) {
        match parse_statement(parser, input) {
            ParseResult::Ok(stmt) => {
                body = add_to_stmt_list(body, stmt);
            }
            ParseResult::Error(msg) => return ParseResult::Error(msg),
        }
    }
    
    match consume(parser, TK_RBRACE(), "Expected '}' after function body") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    return ParseResult::Ok(create_function_node(name, params, body));
}

// Parse struct
fn parse_struct(mut parser: Parser, input: String) -> ParseResult {
    advance(parser); // consume 'struct'
    
    if !check(parser, TK_IDENT()) {
        return ParseResult::Error("Expected struct name");
    }
    
    let name_token = advance(parser);
    let name = get_token_text(parser, name_token, input);
    
    match consume(parser, TK_LBRACE(), "Expected '{' after struct name") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    let mut fields = create_field_def_list();
    
    while !check(parser, TK_RBRACE()) && !is_at_end(parser) {
        if !check(parser, TK_IDENT()) {
            return ParseResult::Error("Expected field name");
        }
        
        let field_token = advance(parser);
        let field_name = get_token_text(parser, field_token, input);
        
        match consume(parser, TK_COLON(), "Expected ':' after field name") {
            ParseResult::Error(msg) => return ParseResult::Error(msg),
            _ => {}
        }
        
        match parse_type(parser, input) {
            ParseResult::Ok(ty) => {
                fields = add_field_def(fields, field_name, ty);
            }
            ParseResult::Error(msg) => return ParseResult::Error(msg),
        }
        
        if !check(parser, TK_RBRACE()) {
            match consume(parser, TK_COMMA(), "Expected ',' after field") {
                ParseResult::Error(msg) => return ParseResult::Error(msg),
                _ => {}
            }
        }
    }
    
    match consume(parser, TK_RBRACE(), "Expected '}' after struct fields") {
        ParseResult::Error(msg) => return ParseResult::Error(msg),
        _ => {}
    }
    
    return ParseResult::Ok(create_struct_node(name, fields));
}

// Parse top-level item
fn parse_item(mut parser: Parser, input: String) -> ParseResult {
    let token = peek(parser);
    
    if token == TK_FN() {
        return parse_function(parser, input);
    }
    if token == TK_STRUCT() {
        return parse_struct(parser, input);
    }
    
    return ParseResult::Error("Expected function or struct");
}

// Parse program
fn parse_program(mut parser: Parser, input: String) -> ParseResult {
    let mut items = create_item_list();
    
    while !is_at_end(parser) {
        match parse_item(parser, input) {
            ParseResult::Ok(item) => {
                items = add_to_item_list(items, item);
            }
            ParseResult::Error(msg) => return ParseResult::Error(msg),
        }
    }
    
    return ParseResult::Ok(create_program_node(items));
}

// Placeholder lexer for testing
struct Lexer {
    tokens: [Token; 1000],
    token_count: i64,
}

fn tokenize(input: String) -> Lexer {
    // This is a placeholder - in reality would use lexer_complete.pd
    let empty_token = Token { kind: 0, line: 0, column: 0, start: 0, length: 0 };
    let mut lex = Lexer {
        tokens: [empty_token; 1000],
        token_count: 0
    };
    
    // Simulate some tokens for testing
    lex.tokens[0] = Token { kind: TK_FN(), line: 1, column: 1, start: 0, length: 2 };
    lex.tokens[1] = Token { kind: TK_IDENT(), line: 1, column: 4, start: 3, length: 4 };
    lex.tokens[2] = Token { kind: TK_LPAREN(), line: 1, column: 8, start: 7, length: 1 };
    lex.tokens[3] = Token { kind: TK_RPAREN(), line: 1, column: 9, start: 8, length: 1 };
    lex.tokens[4] = Token { kind: TK_LBRACE(), line: 1, column: 11, start: 10, length: 1 };
    lex.tokens[5] = Token { kind: TK_RBRACE(), line: 3, column: 1, start: 50, length: 1 };
    lex.tokens[6] = Token { kind: TK_EOF(), line: 3, column: 2, start: 51, length: 0 };
    lex.token_count = 7;
    
    return lex;
}

// Test the parser
fn test_parser() {
    print("=== Complete Palladium Parser ===\n");
    
    // Test 1: Simple function
    print("Test 1: Simple function");
    let input1 = "fn main() {
    let x = 42;
    print_int(x);
}";
    
    let lex1 = tokenize(input1);
    let mut parser1 = parser_new(lex1.tokens, lex1.token_count);
    
    match parse_program(parser1, input1) {
        ParseResult::Ok(ast) => {
            print("✓ Parse successful!");
            print("AST node count:");
            print_int(count_nodes(ast));
        }
        ParseResult::Error(msg) => {
            print("✗ Parse error:");
            print(msg);
        }
    }
    
    // Test 2: Struct and method
    print("\nTest 2: Struct definition");
    let input2 = "struct Point {
    x: i64,
    y: i64,
}

fn distance(p1: Point, p2: Point) -> i64 {
    let dx = p2.x - p1.x;
    let dy = p2.y - p1.y;
    return dx * dx + dy * dy;
}";
    
    let lex2 = tokenize(input2);
    let mut parser2 = parser_new(lex2.tokens, lex2.token_count);
    
    match parse_program(parser2, input2) {
        ParseResult::Ok(ast) => {
            print("✓ Parse successful!");
            print("Items parsed:");
            print_int(count_items(ast));
        }
        ParseResult::Error(msg) => {
            print("✗ Parse error:");
            print(msg);
        }
    }
    
    // Test 3: Control flow
    print("\nTest 3: Control flow");
    let input3 = "fn fizzbuzz(n: i64) {
    for i in 1..n {
        if i % 15 == 0 {
            print(\"FizzBuzz\");
        } else if i % 3 == 0 {
            print(\"Fizz\");
        } else if i % 5 == 0 {
            print(\"Buzz\");
        } else {
            print_int(i);
        }
    }
}";
    
    let lex3 = tokenize(input3);
    let mut parser3 = parser_new(lex3.tokens, lex3.token_count);
    
    match parse_program(parser3, input3) {
        ParseResult::Ok(ast) => {
            print("✓ Parse successful!");
        }
        ParseResult::Error(msg) => {
            print("✗ Parse error:");
            print(msg);
        }
    }
    
    print("\n=== Parser Ready for Bootstrapping! ===");
}

// Helper to check token at offset
fn check_at(parser: Parser, offset: i64, kind: i64) -> bool {
    return peek_ahead(parser, offset) == kind;
}

// Placeholder AST node creation functions
// These would be implemented with proper AST structures

fn NODE_EMPTY() -> i64 { return 0; }

fn create_type_node(kind: i64) -> AstNode {
    return AstNode { kind: kind };
}

fn create_custom_type_node(name: String) -> AstNode {
    return AstNode { kind: 1000 };  // Custom type
}

fn create_array_type_node() -> AstNode {
    return AstNode { kind: 1001 };  // Array type
}

fn create_int_node(value: i64) -> AstNode {
    return AstNode { kind: 2000 };  // Integer literal
}

fn create_string_node(value: String) -> AstNode {
    return AstNode { kind: 2001 };  // String literal
}

fn create_bool_node(value: bool) -> AstNode {
    return AstNode { kind: 2002 };  // Bool literal
}

fn create_ident_node(name: String) -> AstNode {
    return AstNode { kind: 2003 };  // Identifier
}

fn create_binary_node(left: AstNode, op: i64, right: AstNode) -> AstNode {
    return AstNode { kind: 3000 + op };  // Binary expression
}

fn create_call_node(name: String, args: ExprList) -> AstNode {
    return AstNode { kind: 3100 };  // Function call
}

fn create_field_access_node(obj: AstNode, field: String) -> AstNode {
    return AstNode { kind: 3101 };  // Field access
}

fn create_index_node(array: AstNode, index: AstNode) -> AstNode {
    return AstNode { kind: 3102 };  // Array index
}

fn create_struct_literal_node(name: String, fields: FieldList) -> AstNode {
    return AstNode { kind: 3103 };  // Struct literal
}

fn create_array_literal_node(elements: ExprList) -> AstNode {
    return AstNode { kind: 3104 };  // Array literal
}

fn create_array_repeat_node(value: AstNode, count: AstNode) -> AstNode {
    return AstNode { kind: 3105 };  // Array repeat
}

fn create_range_node(start: AstNode, end: AstNode) -> AstNode {
    return AstNode { kind: 3106 };  // Range
}

fn create_unary_node(op: i64, operand: AstNode) -> AstNode {
    return AstNode { kind: 3107 + op };  // Unary expression
}

fn create_let_node(name: String, value: AstNode, mutable: bool) -> AstNode {
    return AstNode { kind: 4000 };  // Let statement
}

fn create_return_node(value: AstNode) -> AstNode {
    return AstNode { kind: 4001 };  // Return statement
}

fn create_return_node_empty() -> AstNode {
    return AstNode { kind: 4002 };  // Return void
}

fn create_if_node(cond: AstNode, then_stmts: StmtList) -> AstNode {
    return AstNode { kind: 4003 };  // If statement
}

fn create_if_else_node(cond: AstNode, then_stmts: StmtList, else_stmts: StmtList) -> AstNode {
    return AstNode { kind: 4004 };  // If-else statement
}

fn create_while_node(cond: AstNode, body: StmtList) -> AstNode {
    return AstNode { kind: 4005 };  // While loop
}

fn create_for_node(var: String, range: AstNode, body: StmtList) -> AstNode {
    return AstNode { kind: 4006 };  // For loop
}

fn create_break_node() -> AstNode {
    return AstNode { kind: 4007 };  // Break
}

fn create_continue_node() -> AstNode {
    return AstNode { kind: 4008 };  // Continue
}

fn create_assign_node(target: AstNode, value: AstNode) -> AstNode {
    return AstNode { kind: 4009 };  // Assignment
}

fn create_expr_stmt_node(expr: AstNode) -> AstNode {
    return AstNode { kind: 4010 };  // Expression statement
}

fn create_param_node(name: String, ty: AstNode, mutable: bool) -> AstNode {
    return AstNode { kind: 5000 };  // Function parameter
}

fn create_function_node(name: String, params: ParamList, body: StmtList) -> AstNode {
    return AstNode { kind: 6000 };  // Function
}

fn create_struct_node(name: String, fields: FieldDefList) -> AstNode {
    return AstNode { kind: 6001 };  // Struct
}

fn create_program_node(items: ItemList) -> AstNode {
    return AstNode { kind: 7000 };  // Program
}

// List types (simplified)
struct ExprList { count: i64 }
struct StmtList { count: i64 }
struct FieldList { count: i64 }
struct FieldDefList { count: i64 }
struct ParamList { count: i64 }
struct ItemList { count: i64 }

fn create_expr_list() -> ExprList { return ExprList { count: 0 }; }
fn create_stmt_list() -> StmtList { return StmtList { count: 0 }; }
fn create_field_list() -> FieldList { return FieldList { count: 0 }; }
fn create_field_def_list() -> FieldDefList { return FieldDefList { count: 0 }; }
fn create_param_list() -> ParamList { return ParamList { count: 0 }; }
fn create_item_list() -> ItemList { return ItemList { count: 0 }; }

fn add_to_expr_list(list: ExprList, expr: AstNode) -> ExprList {
    return ExprList { count: list.count + 1 };
}

fn add_to_stmt_list(list: StmtList, stmt: AstNode) -> StmtList {
    return StmtList { count: list.count + 1 };
}

fn add_field(list: FieldList, name: String, value: AstNode) -> FieldList {
    return FieldList { count: list.count + 1 };
}

fn add_field_def(list: FieldDefList, name: String, ty: AstNode) -> FieldDefList {
    return FieldDefList { count: list.count + 1 };
}

fn add_to_param_list(list: ParamList, param: AstNode) -> ParamList {
    return ParamList { count: list.count + 1 };
}

fn add_to_item_list(list: ItemList, item: AstNode) -> ItemList {
    return ItemList { count: list.count + 1 };
}

fn get_first_expr(list: ExprList) -> AstNode {
    return AstNode { kind: 0 };
}

fn count_nodes(ast: AstNode) -> i64 {
    return 42;  // Placeholder
}

fn count_items(ast: AstNode) -> i64 {
    return 2;  // Placeholder
}

fn main() {
    test_parser();
}