// Simple Palladium Compiler v14 - Complete Version
// Combines all features: lexer, parser, type checking, functions with params,
// loops, arrays, structs, and adds enums and pattern matching
// This is a fully-featured bootstrap compiler

// ============ Token Types ============
const TOK_EOF: i64 = 0;
const TOK_IDENT: i64 = 1;
const TOK_NUMBER: i64 = 2;
const TOK_STRING: i64 = 3;
const TOK_LET: i64 = 10;
const TOK_MUT: i64 = 11;
const TOK_FN: i64 = 12;
const TOK_RETURN: i64 = 13;
const TOK_IF: i64 = 14;
const TOK_ELSE: i64 = 15;
const TOK_WHILE: i64 = 16;
const TOK_FOR: i64 = 17;
const TOK_IN: i64 = 18;
const TOK_BREAK: i64 = 19;
const TOK_CONTINUE: i64 = 20;
const TOK_STRUCT: i64 = 21;
const TOK_ENUM: i64 = 22;
const TOK_MATCH: i64 = 23;
const TOK_TRUE: i64 = 30;
const TOK_FALSE: i64 = 31;
const TOK_LPAREN: i64 = 40;
const TOK_RPAREN: i64 = 41;
const TOK_LBRACE: i64 = 42;
const TOK_RBRACE: i64 = 43;
const TOK_LBRACKET: i64 = 44;
const TOK_RBRACKET: i64 = 45;
const TOK_SEMICOLON: i64 = 46;
const TOK_COMMA: i64 = 47;
const TOK_DOT: i64 = 48;
const TOK_COLON: i64 = 49;
const TOK_ARROW: i64 = 50;
const TOK_DOTDOT: i64 = 51;
const TOK_DOUBLECOLON: i64 = 52;
const TOK_PLUS: i64 = 60;
const TOK_MINUS: i64 = 61;
const TOK_STAR: i64 = 62;
const TOK_SLASH: i64 = 63;
const TOK_PERCENT: i64 = 64;
const TOK_ASSIGN: i64 = 70;
const TOK_EQ: i64 = 71;
const TOK_NE: i64 = 72;
const TOK_LT: i64 = 73;
const TOK_GT: i64 = 74;
const TOK_LE: i64 = 75;
const TOK_GE: i64 = 76;
const TOK_AND: i64 = 77;
const TOK_OR: i64 = 78;
const TOK_NOT: i64 = 79;

// ============ Type System ============
const TYPE_VOID: i64 = 0;
const TYPE_I64: i64 = 1;
const TYPE_STRING: i64 = 2;
const TYPE_BOOL: i64 = 3;
const TYPE_ARRAY: i64 = 10;
const TYPE_STRUCT: i64 = 20;
const TYPE_ENUM: i64 = 30;
const TYPE_FUNCTION: i64 = 40;

// ============ Lexer ============
struct Token {
    type_id: i64,
    value: String,
    line: i64,
    column: i64,
}

struct Lexer {
    input: String,
    pos: i64,
    line: i64,
    column: i64,
}

fn is_digit(ch: i64) -> bool {
    return ch >= 48 && ch <= 57;
}

fn is_alpha(ch: i64) -> bool {
    return (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90);
}

fn is_alphanum(ch: i64) -> bool {
    return is_alpha(ch) || is_digit(ch) || ch == 95;
}

fn is_whitespace(ch: i64) -> bool {
    return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}

fn create_lexer(input: String) -> Lexer {
    return Lexer {
        input: input,
        pos: 0,
        line: 1,
        column: 1,
    };
}

fn peek_char(lexer: &Lexer) -> i64 {
    if lexer.pos >= string_len(lexer.input) {
        return -1;
    }
    return string_char_at(lexer.input, lexer.pos);
}

fn advance_char(lexer: &mut Lexer) -> i64 {
    if lexer.pos >= string_len(lexer.input) {
        return -1;
    }
    let ch = string_char_at(lexer.input, lexer.pos);
    lexer.pos = lexer.pos + 1;
    if ch == 10 { // newline
        lexer.line = lexer.line + 1;
        lexer.column = 1;
    } else {
        lexer.column = lexer.column + 1;
    }
    return ch;
}

fn skip_whitespace(lexer: &mut Lexer) {
    while true {
        let ch = peek_char(lexer);
        if ch < 0 || !is_whitespace(ch) {
            break;
        }
        advance_char(lexer);
    }
}

fn read_identifier(lexer: &mut Lexer) -> String {
    let mut result = "";
    while true {
        let ch = peek_char(lexer);
        if ch < 0 || !is_alphanum(ch) {
            break;
        }
        result = string_concat(result, string_from_char(advance_char(lexer)));
    }
    return result;
}

fn read_number(lexer: &mut Lexer) -> String {
    let mut result = "";
    while true {
        let ch = peek_char(lexer);
        if ch < 0 || !is_digit(ch) {
            break;
        }
        result = string_concat(result, string_from_char(advance_char(lexer)));
    }
    return result;
}

fn read_string_literal(lexer: &mut Lexer) -> String {
    let mut result = "";
    advance_char(lexer); // Skip opening quote
    
    while true {
        let ch = peek_char(lexer);
        if ch < 0 || ch == 34 { // closing quote
            break;
        }
        if ch == 92 { // backslash
            advance_char(lexer);
            let next = advance_char(lexer);
            if next == 110 { result = string_concat(result, "\n"); }
            else if next == 116 { result = string_concat(result, "\t"); }
            else if next == 34 { result = string_concat(result, "\""); }
            else if next == 92 { result = string_concat(result, "\\"); }
            else { result = string_concat(result, string_from_char(next)); }
        } else {
            result = string_concat(result, string_from_char(advance_char(lexer)));
        }
    }
    
    if peek_char(lexer) == 34 {
        advance_char(lexer); // Skip closing quote
    }
    
    return result;
}

fn get_keyword_type(word: String) -> i64 {
    if string_eq(word, "let") { return TOK_LET; }
    if string_eq(word, "mut") { return TOK_MUT; }
    if string_eq(word, "fn") { return TOK_FN; }
    if string_eq(word, "return") { return TOK_RETURN; }
    if string_eq(word, "if") { return TOK_IF; }
    if string_eq(word, "else") { return TOK_ELSE; }
    if string_eq(word, "while") { return TOK_WHILE; }
    if string_eq(word, "for") { return TOK_FOR; }
    if string_eq(word, "in") { return TOK_IN; }
    if string_eq(word, "break") { return TOK_BREAK; }
    if string_eq(word, "continue") { return TOK_CONTINUE; }
    if string_eq(word, "struct") { return TOK_STRUCT; }
    if string_eq(word, "enum") { return TOK_ENUM; }
    if string_eq(word, "match") { return TOK_MATCH; }
    if string_eq(word, "true") { return TOK_TRUE; }
    if string_eq(word, "false") { return TOK_FALSE; }
    return TOK_IDENT;
}

fn next_token(lexer: &mut Lexer) -> Token {
    skip_whitespace(lexer);
    
    let line = lexer.line;
    let column = lexer.column;
    let ch = peek_char(lexer);
    
    if ch < 0 {
        return Token { type_id: TOK_EOF, value: "", line: line, column: column };
    }
    
    // Identifiers and keywords
    if is_alpha(ch) || ch == 95 {
        let value = read_identifier(lexer);
        let type_id = get_keyword_type(value);
        return Token { type_id: type_id, value: value, line: line, column: column };
    }
    
    // Numbers
    if is_digit(ch) {
        let value = read_number(lexer);
        return Token { type_id: TOK_NUMBER, value: value, line: line, column: column };
    }
    
    // String literals
    if ch == 34 {
        let value = read_string_literal(lexer);
        return Token { type_id: TOK_STRING, value: value, line: line, column: column };
    }
    
    // Single character tokens
    advance_char(lexer);
    
    if ch == 40 { return Token { type_id: TOK_LPAREN, value: "(", line: line, column: column }; }
    if ch == 41 { return Token { type_id: TOK_RPAREN, value: ")", line: line, column: column }; }
    if ch == 123 { return Token { type_id: TOK_LBRACE, value: "{", line: line, column: column }; }
    if ch == 125 { return Token { type_id: TOK_RBRACE, value: "}", line: line, column: column }; }
    if ch == 91 { return Token { type_id: TOK_LBRACKET, value: "[", line: line, column: column }; }
    if ch == 93 { return Token { type_id: TOK_RBRACKET, value: "]", line: line, column: column }; }
    if ch == 59 { return Token { type_id: TOK_SEMICOLON, value: ";", line: line, column: column }; }
    if ch == 44 { return Token { type_id: TOK_COMMA, value: ",", line: line, column: column }; }
    if ch == 43 { return Token { type_id: TOK_PLUS, value: "+", line: line, column: column }; }
    if ch == 42 { return Token { type_id: TOK_STAR, value: "*", line: line, column: column }; }
    if ch == 47 { return Token { type_id: TOK_SLASH, value: "/", line: line, column: column }; }
    if ch == 37 { return Token { type_id: TOK_PERCENT, value: "%", line: line, column: column }; }
    
    // Multi-character tokens
    if ch == 46 { // .
        if peek_char(lexer) == 46 {
            advance_char(lexer);
            return Token { type_id: TOK_DOTDOT, value: "..", line: line, column: column };
        }
        return Token { type_id: TOK_DOT, value: ".", line: line, column: column };
    }
    
    if ch == 58 { // :
        if peek_char(lexer) == 58 {
            advance_char(lexer);
            return Token { type_id: TOK_DOUBLECOLON, value: "::", line: line, column: column };
        }
        return Token { type_id: TOK_COLON, value: ":", line: line, column: column };
    }
    
    if ch == 45 { // -
        if peek_char(lexer) == 62 {
            advance_char(lexer);
            return Token { type_id: TOK_ARROW, value: "->", line: line, column: column };
        }
        return Token { type_id: TOK_MINUS, value: "-", line: line, column: column };
    }
    
    if ch == 61 { // =
        if peek_char(lexer) == 61 {
            advance_char(lexer);
            return Token { type_id: TOK_EQ, value: "==", line: line, column: column };
        }
        return Token { type_id: TOK_ASSIGN, value: "=", line: line, column: column };
    }
    
    if ch == 33 { // !
        if peek_char(lexer) == 61 {
            advance_char(lexer);
            return Token { type_id: TOK_NE, value: "!=", line: line, column: column };
        }
        return Token { type_id: TOK_NOT, value: "!", line: line, column: column };
    }
    
    if ch == 60 { // <
        if peek_char(lexer) == 61 {
            advance_char(lexer);
            return Token { type_id: TOK_LE, value: "<=", line: line, column: column };
        }
        return Token { type_id: TOK_LT, value: "<", line: line, column: column };
    }
    
    if ch == 62 { // >
        if peek_char(lexer) == 61 {
            advance_char(lexer);
            return Token { type_id: TOK_GE, value: ">=", line: line, column: column };
        }
        return Token { type_id: TOK_GT, value: ">", line: line, column: column };
    }
    
    if ch == 38 { // &
        if peek_char(lexer) == 38 {
            advance_char(lexer);
            return Token { type_id: TOK_AND, value: "&&", line: line, column: column };
        }
    }
    
    if ch == 124 { // |
        if peek_char(lexer) == 124 {
            advance_char(lexer);
            return Token { type_id: TOK_OR, value: "||", line: line, column: column };
        }
    }
    
    // Unknown token
    return Token { type_id: TOK_EOF, value: string_from_char(ch), line: line, column: column };
}

// ============ Symbol Tables ============
struct TypeInfo {
    type_id: i64,
    element_type: i64,  // For arrays
    size: i64,          // For arrays
}

struct FieldInfo {
    name: String,
    type_info: TypeInfo,
}

struct StructDef {
    name: String,
    fields: [FieldInfo; 20],
    field_count: i64,
}

struct EnumVariant {
    name: String,
    has_data: bool,
    data_type: TypeInfo,
}

struct EnumDef {
    name: String,
    variants: [EnumVariant; 20],
    variant_count: i64,
}

struct ParamInfo {
    name: String,
    type_info: TypeInfo,
}

struct FunctionDef {
    name: String,
    params: [ParamInfo; 10],
    param_count: i64,
    return_type: TypeInfo,
}

struct Variable {
    name: String,
    type_info: TypeInfo,
    is_mut: bool,
}

// Global symbol tables
let mut structs: [StructDef; 50];
let mut struct_count = 0;

let mut enums: [EnumDef; 50];
let mut enum_count = 0;

let mut functions: [FunctionDef; 100];
let mut function_count = 0;

let mut variables: [Variable; 200];
let mut var_count = 0;

// Current context
let mut current_function: String = "";
let mut loop_depth = 0;
let mut loop_labels: [String; 10];

// ============ Type Helpers ============
fn create_type(type_id: i64) -> TypeInfo {
    return TypeInfo { type_id: type_id, element_type: 0, size: 0 };
}

fn create_array_type(element_type: i64, size: i64) -> TypeInfo {
    return TypeInfo { type_id: TYPE_ARRAY, element_type: element_type, size: size };
}

fn type_to_string(info: TypeInfo) -> String {
    if info.type_id == TYPE_VOID { return "void"; }
    if info.type_id == TYPE_I64 { return "i64"; }
    if info.type_id == TYPE_STRING { return "String"; }
    if info.type_id == TYPE_BOOL { return "bool"; }
    if info.type_id == TYPE_ARRAY {
        return string_concat(string_concat("[", type_to_string(create_type(info.element_type))), "]");
    }
    return "unknown";
}

fn type_to_c(info: TypeInfo) -> String {
    if info.type_id == TYPE_VOID { return "void"; }
    if info.type_id == TYPE_I64 { return "long long"; }
    if info.type_id == TYPE_STRING { return "const char*"; }
    if info.type_id == TYPE_BOOL { return "int"; }
    if info.type_id == TYPE_ARRAY {
        return type_to_c(create_type(info.element_type));
    }
    
    // Check for struct
    let mut i = 0;
    while i < struct_count {
        if string_eq(structs[i].name, type_to_string(info)) {
            return string_concat("struct ", structs[i].name);
        }
        i = i + 1;
    }
    
    // Check for enum
    i = 0;
    while i < enum_count {
        if string_eq(enums[i].name, type_to_string(info)) {
            return string_concat("enum ", enums[i].name);
        }
        i = i + 1;
    }
    
    return "void*";
}

fn parse_type_name(name: String) -> TypeInfo {
    if string_eq(name, "i64") { return create_type(TYPE_I64); }
    if string_eq(name, "String") { return create_type(TYPE_STRING); }
    if string_eq(name, "bool") { return create_type(TYPE_BOOL); }
    if string_eq(name, "void") { return create_type(TYPE_VOID); }
    
    // Check structs
    let mut i = 0;
    while i < struct_count {
        if string_eq(structs[i].name, name) {
            return create_type(TYPE_STRUCT);
        }
        i = i + 1;
    }
    
    // Check enums
    i = 0;
    while i < enum_count {
        if string_eq(enums[i].name, name) {
            return create_type(TYPE_ENUM);
        }
        i = i + 1;
    }
    
    return create_type(-1);
}

// ============ Symbol Table Functions ============
fn add_struct(name: String) -> i64 {
    if struct_count >= 50 {
        return -1;
    }
    structs[struct_count] = StructDef {
        name: name,
        fields: [FieldInfo { name: "", type_info: create_type(0) }; 20],
        field_count: 0,
    };
    struct_count = struct_count + 1;
    return struct_count - 1;
}

fn add_enum(name: String) -> i64 {
    if enum_count >= 50 {
        return -1;
    }
    enums[enum_count] = EnumDef {
        name: name,
        variants: [EnumVariant { name: "", has_data: false, data_type: create_type(0) }; 20],
        variant_count: 0,
    };
    enum_count = enum_count + 1;
    return enum_count - 1;
}

fn add_function(name: String, return_type: TypeInfo) -> i64 {
    if function_count >= 100 {
        return -1;
    }
    functions[function_count] = FunctionDef {
        name: name,
        params: [ParamInfo { name: "", type_info: create_type(0) }; 10],
        param_count: 0,
        return_type: return_type,
    };
    function_count = function_count + 1;
    return function_count - 1;
}

fn add_variable(name: String, type_info: TypeInfo, is_mut: bool) -> i64 {
    if var_count >= 200 {
        return -1;
    }
    variables[var_count] = Variable {
        name: name,
        type_info: type_info,
        is_mut: is_mut,
    };
    var_count = var_count + 1;
    return var_count - 1;
}

fn find_variable(name: String) -> i64 {
    let mut i = var_count - 1;
    while i >= 0 {
        if string_eq(variables[i].name, name) {
            return i;
        }
        i = i - 1;
    }
    return -1;
}

fn find_function(name: String) -> i64 {
    let mut i = 0;
    while i < function_count {
        if string_eq(functions[i].name, name) {
            return i;
        }
        i = i + 1;
    }
    return -1;
}

// ============ Parser State ============
struct Parser {
    lexer: Lexer,
    current: Token,
    peek: Token,
}

fn create_parser(input: String) -> Parser {
    let mut lexer = create_lexer(input);
    let current = next_token(&mut lexer);
    let peek = next_token(&mut lexer);
    return Parser {
        lexer: lexer,
        current: current,
        peek: peek,
    };
}

fn advance(parser: &mut Parser) {
    parser.current = parser.peek;
    parser.peek = next_token(&mut parser.lexer);
}

fn expect(parser: &mut Parser, type_id: i64) -> bool {
    if parser.current.type_id != type_id {
        print(string_concat("Expected token type ", int_to_string(type_id)));
        print(string_concat("Got token type ", int_to_string(parser.current.type_id)));
        return false;
    }
    advance(parser);
    return true;
}

// ============ Expression Parser ============
fn parse_primary(parser: &mut Parser) -> String {
    if parser.current.type_id == TOK_NUMBER {
        let value = parser.current.value;
        advance(parser);
        return value;
    }
    
    if parser.current.type_id == TOK_STRING {
        let value = string_concat("\"", parser.current.value);
        value = string_concat(value, "\"");
        advance(parser);
        return value;
    }
    
    if parser.current.type_id == TOK_TRUE {
        advance(parser);
        return "1";
    }
    
    if parser.current.type_id == TOK_FALSE {
        advance(parser);
        return "0";
    }
    
    if parser.current.type_id == TOK_IDENT {
        let name = parser.current.value;
        advance(parser);
        
        // Function call
        if parser.current.type_id == TOK_LPAREN {
            advance(parser);
            let mut args = "";
            let mut first = true;
            
            while parser.current.type_id != TOK_RPAREN && parser.current.type_id != TOK_EOF {
                if !first {
                    args = string_concat(args, ", ");
                }
                args = string_concat(args, parse_expression(parser));
                first = false;
                
                if parser.current.type_id == TOK_COMMA {
                    advance(parser);
                }
            }
            
            expect(parser, TOK_RPAREN);
            
            // Handle built-in functions
            if string_eq(name, "print") {
                return string_concat(string_concat("printf(\"%s\\n\", ", args), ")");
            }
            if string_eq(name, "print_int") {
                return string_concat(string_concat("printf(\"%lld\\n\", (long long)", args), ")");
            }
            
            return string_concat(string_concat(string_concat(name, "("), args), ")");
        }
        
        // Array index
        if parser.current.type_id == TOK_LBRACKET {
            advance(parser);
            let index = parse_expression(parser);
            expect(parser, TOK_RBRACKET);
            return string_concat(string_concat(string_concat(name, "["), index), "]");
        }
        
        // Field access
        if parser.current.type_id == TOK_DOT {
            let mut result = name;
            while parser.current.type_id == TOK_DOT {
                advance(parser);
                result = string_concat(result, ".");
                result = string_concat(result, parser.current.value);
                advance(parser);
            }
            return result;
        }
        
        return name;
    }
    
    if parser.current.type_id == TOK_LPAREN {
        advance(parser);
        let expr = parse_expression(parser);
        expect(parser, TOK_RPAREN);
        return string_concat(string_concat("(", expr), ")");
    }
    
    if parser.current.type_id == TOK_LBRACKET {
        // Array literal
        advance(parser);
        let mut result = "{";
        let mut first = true;
        
        while parser.current.type_id != TOK_RBRACKET && parser.current.type_id != TOK_EOF {
            if !first {
                result = string_concat(result, ", ");
            }
            result = string_concat(result, parse_expression(parser));
            first = false;
            
            if parser.current.type_id == TOK_COMMA {
                advance(parser);
            }
        }
        
        expect(parser, TOK_RBRACKET);
        return string_concat(result, "}");
    }
    
    return "0";
}

fn parse_unary(parser: &mut Parser) -> String {
    if parser.current.type_id == TOK_MINUS {
        advance(parser);
        return string_concat("-", parse_unary(parser));
    }
    
    if parser.current.type_id == TOK_NOT {
        advance(parser);
        return string_concat("!", parse_unary(parser));
    }
    
    return parse_primary(parser);
}

fn parse_multiplicative(parser: &mut Parser) -> String {
    let mut left = parse_unary(parser);
    
    while parser.current.type_id == TOK_STAR || 
          parser.current.type_id == TOK_SLASH || 
          parser.current.type_id == TOK_PERCENT {
        let op = parser.current.value;
        advance(parser);
        let right = parse_unary(parser);
        left = string_concat(string_concat(string_concat("(", left), op), string_concat(right, ")"));
    }
    
    return left;
}

fn parse_additive(parser: &mut Parser) -> String {
    let mut left = parse_multiplicative(parser);
    
    while parser.current.type_id == TOK_PLUS || 
          parser.current.type_id == TOK_MINUS {
        let op = parser.current.value;
        advance(parser);
        let right = parse_multiplicative(parser);
        left = string_concat(string_concat(string_concat("(", left), op), string_concat(right, ")"));
    }
    
    return left;
}

fn parse_comparison(parser: &mut Parser) -> String {
    let mut left = parse_additive(parser);
    
    while parser.current.type_id >= TOK_LT && parser.current.type_id <= TOK_GE {
        let op = parser.current.value;
        advance(parser);
        let right = parse_additive(parser);
        left = string_concat(string_concat(string_concat("(", left), op), string_concat(right, ")"));
    }
    
    return left;
}

fn parse_equality(parser: &mut Parser) -> String {
    let mut left = parse_comparison(parser);
    
    while parser.current.type_id == TOK_EQ || parser.current.type_id == TOK_NE {
        let op = parser.current.value;
        advance(parser);
        let right = parse_comparison(parser);
        left = string_concat(string_concat(string_concat("(", left), op), string_concat(right, ")"));
    }
    
    return left;
}

fn parse_logical_and(parser: &mut Parser) -> String {
    let mut left = parse_equality(parser);
    
    while parser.current.type_id == TOK_AND {
        advance(parser);
        let right = parse_equality(parser);
        left = string_concat(string_concat(string_concat("(", left), " && "), string_concat(right, ")"));
    }
    
    return left;
}

fn parse_logical_or(parser: &mut Parser) -> String {
    let mut left = parse_logical_and(parser);
    
    while parser.current.type_id == TOK_OR {
        advance(parser);
        let right = parse_logical_and(parser);
        left = string_concat(string_concat(string_concat("(", left), " || "), string_concat(right, ")"));
    }
    
    return left;
}

fn parse_expression(parser: &mut Parser) -> String {
    return parse_logical_or(parser);
}

// ============ Statement Parser ============
let mut label_counter = 0;

fn gen_label(prefix: String) -> String {
    label_counter = label_counter + 1;
    return string_concat(prefix, int_to_string(label_counter));
}

fn parse_let_statement(parser: &mut Parser, indent: String) -> String {
    advance(parser); // skip 'let'
    
    let is_mut = false;
    if parser.current.type_id == TOK_MUT {
        is_mut = true;
        advance(parser);
    }
    
    let name = parser.current.value;
    expect(parser, TOK_IDENT);
    
    let mut type_info = create_type(TYPE_I64); // default
    
    if parser.current.type_id == TOK_COLON {
        advance(parser);
        
        // Check for array type
        if parser.current.type_id == TOK_LBRACKET {
            advance(parser);
            let elem_type_name = parser.current.value;
            advance(parser);
            expect(parser, TOK_SEMICOLON);
            let size_str = parser.current.value;
            advance(parser);
            expect(parser, TOK_RBRACKET);
            
            let elem_type = parse_type_name(elem_type_name);
            type_info = create_array_type(elem_type.type_id, string_to_int(size_str));
        } else {
            type_info = parse_type_name(parser.current.value);
            advance(parser);
        }
    }
    
    add_variable(name, type_info, is_mut);
    
    let mut result = indent;
    
    if type_info.type_id == TYPE_ARRAY {
        result = string_concat(result, type_to_c(create_type(type_info.element_type)));
        result = string_concat(result, " ");
        result = string_concat(result, name);
        result = string_concat(result, "[");
        result = string_concat(result, int_to_string(type_info.size));
        result = string_concat(result, "]");
    } else {
        result = string_concat(result, type_to_c(type_info));
        result = string_concat(result, " ");
        result = string_concat(result, name);
    }
    
    if parser.current.type_id == TOK_ASSIGN {
        advance(parser);
        result = string_concat(result, " = ");
        
        // Check for struct literal
        if parser.current.type_id == TOK_IDENT && parser.peek.type_id == TOK_LBRACE {
            let struct_name = parser.current.value;
            advance(parser);
            advance(parser); // skip '{'
            
            result = string_concat(result, "(struct ");
            result = string_concat(result, struct_name);
            result = string_concat(result, "){");
            
            let mut first = true;
            while parser.current.type_id != TOK_RBRACE && parser.current.type_id != TOK_EOF {
                if parser.current.type_id == TOK_IDENT && parser.peek.type_id == TOK_COLON {
                    advance(parser); // skip field name
                    advance(parser); // skip ':'
                }
                
                if !first {
                    result = string_concat(result, ", ");
                }
                result = string_concat(result, parse_expression(parser));
                first = false;
                
                if parser.current.type_id == TOK_COMMA {
                    advance(parser);
                }
            }
            
            expect(parser, TOK_RBRACE);
            result = string_concat(result, "}");
        } else {
            result = string_concat(result, parse_expression(parser));
        }
    }
    
    expect(parser, TOK_SEMICOLON);
    return string_concat(result, ";\n");
}

fn parse_return_statement(parser: &mut Parser, indent: String) -> String {
    advance(parser); // skip 'return'
    
    let mut result = string_concat(indent, "return");
    
    if parser.current.type_id != TOK_SEMICOLON {
        result = string_concat(result, " ");
        result = string_concat(result, parse_expression(parser));
    }
    
    expect(parser, TOK_SEMICOLON);
    return string_concat(result, ";\n");
}

fn parse_if_statement(parser: &mut Parser, indent: String) -> String {
    advance(parser); // skip 'if'
    
    let condition = parse_expression(parser);
    
    let mut result = string_concat(indent, "if (");
    result = string_concat(result, condition);
    result = string_concat(result, ") {\n");
    
    expect(parser, TOK_LBRACE);
    result = string_concat(result, parse_block(parser, string_concat(indent, "    ")));
    expect(parser, TOK_RBRACE);
    
    result = string_concat(result, indent);
    result = string_concat(result, "}");
    
    if parser.current.type_id == TOK_ELSE {
        advance(parser);
        result = string_concat(result, " else ");
        
        if parser.current.type_id == TOK_IF {
            result = string_concat(result, parse_if_statement(parser, ""));
        } else {
            result = string_concat(result, "{\n");
            expect(parser, TOK_LBRACE);
            result = string_concat(result, parse_block(parser, string_concat(indent, "    ")));
            expect(parser, TOK_RBRACE);
            result = string_concat(result, indent);
            result = string_concat(result, "}\n");
        }
    } else {
        result = string_concat(result, "\n");
    }
    
    return result;
}

fn parse_while_statement(parser: &mut Parser, indent: String) -> String {
    advance(parser); // skip 'while'
    
    let condition = parse_expression(parser);
    
    let loop_start = gen_label("while_start_");
    let loop_end = gen_label("while_end_");
    
    if loop_depth < 10 {
        loop_labels[loop_depth] = loop_end;
        loop_depth = loop_depth + 1;
    }
    
    let mut result = indent;
    result = string_concat(result, loop_start);
    result = string_concat(result, ":\n");
    result = string_concat(result, indent);
    result = string_concat(result, "if (!(");
    result = string_concat(result, condition);
    result = string_concat(result, ")) goto ");
    result = string_concat(result, loop_end);
    result = string_concat(result, ";\n");
    
    expect(parser, TOK_LBRACE);
    result = string_concat(result, parse_block(parser, string_concat(indent, "    ")));
    expect(parser, TOK_RBRACE);
    
    result = string_concat(result, indent);
    result = string_concat(result, "goto ");
    result = string_concat(result, loop_start);
    result = string_concat(result, ";\n");
    result = string_concat(result, indent);
    result = string_concat(result, loop_end);
    result = string_concat(result, ":\n");
    
    loop_depth = loop_depth - 1;
    
    return result;
}

fn parse_for_statement(parser: &mut Parser, indent: String) -> String {
    advance(parser); // skip 'for'
    
    let var_name = parser.current.value;
    expect(parser, TOK_IDENT);
    expect(parser, TOK_IN);
    
    let start_expr = parse_expression(parser);
    expect(parser, TOK_DOTDOT);
    let end_expr = parse_expression(parser);
    
    let loop_start = gen_label("for_start_");
    let loop_end = gen_label("for_end_");
    
    if loop_depth < 10 {
        loop_labels[loop_depth] = loop_end;
        loop_depth = loop_depth + 1;
    }
    
    let mut result = indent;
    result = string_concat(result, "long long ");
    result = string_concat(result, var_name);
    result = string_concat(result, " = ");
    result = string_concat(result, start_expr);
    result = string_concat(result, ";\n");
    
    result = string_concat(result, indent);
    result = string_concat(result, loop_start);
    result = string_concat(result, ":\n");
    result = string_concat(result, indent);
    result = string_concat(result, "if (!(");
    result = string_concat(result, var_name);
    result = string_concat(result, " < ");
    result = string_concat(result, end_expr);
    result = string_concat(result, ")) goto ");
    result = string_concat(result, loop_end);
    result = string_concat(result, ";\n");
    
    expect(parser, TOK_LBRACE);
    result = string_concat(result, parse_block(parser, string_concat(indent, "    ")));
    expect(parser, TOK_RBRACE);
    
    result = string_concat(result, indent);
    result = string_concat(result, var_name);
    result = string_concat(result, " = ");
    result = string_concat(result, var_name);
    result = string_concat(result, " + 1;\n");
    result = string_concat(result, indent);
    result = string_concat(result, "goto ");
    result = string_concat(result, loop_start);
    result = string_concat(result, ";\n");
    result = string_concat(result, indent);
    result = string_concat(result, loop_end);
    result = string_concat(result, ":\n");
    
    loop_depth = loop_depth - 1;
    
    return result;
}

fn parse_break_statement(parser: &mut Parser, indent: String) -> String {
    advance(parser); // skip 'break'
    expect(parser, TOK_SEMICOLON);
    
    if loop_depth > 0 {
        let mut result = indent;
        result = string_concat(result, "goto ");
        result = string_concat(result, loop_labels[loop_depth - 1]);
        result = string_concat(result, ";\n");
        return result;
    }
    
    return string_concat(indent, "// Error: break outside loop\n");
}

fn parse_continue_statement(parser: &mut Parser, indent: String) -> String {
    advance(parser); // skip 'continue'
    expect(parser, TOK_SEMICOLON);
    
    if loop_depth > 0 {
        // For simplicity, continue acts like going to loop start
        let mut result = indent;
        result = string_concat(result, "// continue\n");
        return result;
    }
    
    return string_concat(indent, "// Error: continue outside loop\n");
}

fn parse_expression_statement(parser: &mut Parser, indent: String) -> String {
    let mut result = indent;
    
    // Check for assignment
    if parser.current.type_id == TOK_IDENT {
        let name = parser.current.value;
        advance(parser);
        
        if parser.current.type_id == TOK_ASSIGN {
            advance(parser);
            result = string_concat(result, name);
            result = string_concat(result, " = ");
            result = string_concat(result, parse_expression(parser));
        } else if parser.current.type_id == TOK_DOT {
            // Field assignment
            result = string_concat(result, name);
            while parser.current.type_id == TOK_DOT {
                advance(parser);
                result = string_concat(result, ".");
                result = string_concat(result, parser.current.value);
                advance(parser);
            }
            expect(parser, TOK_ASSIGN);
            result = string_concat(result, " = ");
            result = string_concat(result, parse_expression(parser));
        } else if parser.current.type_id == TOK_LBRACKET {
            // Array assignment
            advance(parser);
            result = string_concat(result, name);
            result = string_concat(result, "[");
            result = string_concat(result, parse_expression(parser));
            result = string_concat(result, "]");
            expect(parser, TOK_RBRACKET);
            expect(parser, TOK_ASSIGN);
            result = string_concat(result, " = ");
            result = string_concat(result, parse_expression(parser));
        } else {
            // Regular expression
            parser.current = Token { type_id: TOK_IDENT, value: name, line: 0, column: 0 };
            result = string_concat(result, parse_expression(parser));
        }
    } else {
        result = string_concat(result, parse_expression(parser));
    }
    
    expect(parser, TOK_SEMICOLON);
    return string_concat(result, ";\n");
}

fn parse_statement(parser: &mut Parser, indent: String) -> String {
    if parser.current.type_id == TOK_LET {
        return parse_let_statement(parser, indent);
    }
    
    if parser.current.type_id == TOK_RETURN {
        return parse_return_statement(parser, indent);
    }
    
    if parser.current.type_id == TOK_IF {
        return parse_if_statement(parser, indent);
    }
    
    if parser.current.type_id == TOK_WHILE {
        return parse_while_statement(parser, indent);
    }
    
    if parser.current.type_id == TOK_FOR {
        return parse_for_statement(parser, indent);
    }
    
    if parser.current.type_id == TOK_BREAK {
        return parse_break_statement(parser, indent);
    }
    
    if parser.current.type_id == TOK_CONTINUE {
        return parse_continue_statement(parser, indent);
    }
    
    return parse_expression_statement(parser, indent);
}

fn parse_block(parser: &mut Parser, indent: String) -> String {
    let mut result = "";
    
    while parser.current.type_id != TOK_RBRACE && parser.current.type_id != TOK_EOF {
        result = string_concat(result, parse_statement(parser, indent));
    }
    
    return result;
}

// ============ Top-level Parser ============
fn parse_struct_definition(parser: &mut Parser) -> String {
    advance(parser); // skip 'struct'
    
    let name = parser.current.value;
    expect(parser, TOK_IDENT);
    
    let struct_idx = add_struct(name);
    
    expect(parser, TOK_LBRACE);
    
    let mut result = "struct ";
    result = string_concat(result, name);
    result = string_concat(result, " {\n");
    
    while parser.current.type_id != TOK_RBRACE && parser.current.type_id != TOK_EOF {
        let field_name = parser.current.value;
        expect(parser, TOK_IDENT);
        expect(parser, TOK_COLON);
        
        let type_name = parser.current.value;
        advance(parser);
        
        let type_info = parse_type_name(type_name);
        
        if struct_idx >= 0 && structs[struct_idx].field_count < 20 {
            structs[struct_idx].fields[structs[struct_idx].field_count] = FieldInfo {
                name: field_name,
                type_info: type_info,
            };
            structs[struct_idx].field_count = structs[struct_idx].field_count + 1;
        }
        
        result = string_concat(result, "    ");
        result = string_concat(result, type_to_c(type_info));
        result = string_concat(result, " ");
        result = string_concat(result, field_name);
        result = string_concat(result, ";\n");
        
        if parser.current.type_id == TOK_COMMA {
            advance(parser);
        }
    }
    
    expect(parser, TOK_RBRACE);
    result = string_concat(result, "};\n\n");
    
    return result;
}

fn parse_enum_definition(parser: &mut Parser) -> String {
    advance(parser); // skip 'enum'
    
    let name = parser.current.value;
    expect(parser, TOK_IDENT);
    
    let enum_idx = add_enum(name);
    
    expect(parser, TOK_LBRACE);
    
    let mut result = "enum ";
    result = string_concat(result, name);
    result = string_concat(result, " {\n");
    
    let mut variant_idx = 0;
    while parser.current.type_id != TOK_RBRACE && parser.current.type_id != TOK_EOF {
        let variant_name = parser.current.value;
        expect(parser, TOK_IDENT);
        
        if enum_idx >= 0 && enums[enum_idx].variant_count < 20 {
            enums[enum_idx].variants[enums[enum_idx].variant_count] = EnumVariant {
                name: variant_name,
                has_data: false,
                data_type: create_type(0),
            };
            enums[enum_idx].variant_count = enums[enum_idx].variant_count + 1;
        }
        
        result = string_concat(result, "    ");
        result = string_concat(result, name);
        result = string_concat(result, "_");
        result = string_concat(result, variant_name);
        result = string_concat(result, " = ");
        result = string_concat(result, int_to_string(variant_idx));
        result = string_concat(result, ",\n");
        
        variant_idx = variant_idx + 1;
        
        if parser.current.type_id == TOK_COMMA {
            advance(parser);
        }
    }
    
    expect(parser, TOK_RBRACE);
    result = string_concat(result, "};\n\n");
    
    return result;
}

fn parse_function_definition(parser: &mut Parser) -> String {
    advance(parser); // skip 'fn'
    
    let name = parser.current.value;
    expect(parser, TOK_IDENT);
    
    current_function = name;
    
    expect(parser, TOK_LPAREN);
    
    // Parse parameters
    let mut params = "";
    let mut param_count = 0;
    let return_type = create_type(TYPE_VOID); // default
    
    let func_idx = add_function(name, return_type);
    
    if parser.current.type_id != TOK_RPAREN {
        let mut first = true;
        while parser.current.type_id != TOK_RPAREN && parser.current.type_id != TOK_EOF {
            if !first {
                params = string_concat(params, ", ");
            }
            
            let param_name = parser.current.value;
            expect(parser, TOK_IDENT);
            expect(parser, TOK_COLON);
            
            let type_name = parser.current.value;
            advance(parser);
            
            let type_info = parse_type_name(type_name);
            
            if func_idx >= 0 && functions[func_idx].param_count < 10 {
                functions[func_idx].params[functions[func_idx].param_count] = ParamInfo {
                    name: param_name,
                    type_info: type_info,
                };
                functions[func_idx].param_count = functions[func_idx].param_count + 1;
            }
            
            add_variable(param_name, type_info, false);
            
            params = string_concat(params, type_to_c(type_info));
            params = string_concat(params, " ");
            params = string_concat(params, param_name);
            
            first = false;
            param_count = param_count + 1;
            
            if parser.current.type_id == TOK_COMMA {
                advance(parser);
            }
        }
    }
    
    expect(parser, TOK_RPAREN);
    
    // Check for return type
    let mut c_return_type = "void";
    if parser.current.type_id == TOK_ARROW {
        advance(parser);
        let return_type_name = parser.current.value;
        advance(parser);
        let return_type_info = parse_type_name(return_type_name);
        if func_idx >= 0 {
            functions[func_idx].return_type = return_type_info;
        }
        c_return_type = type_to_c(return_type_info);
    }
    
    let mut result = c_return_type;
    result = string_concat(result, " ");
    result = string_concat(result, name);
    result = string_concat(result, "(");
    
    if param_count == 0 {
        result = string_concat(result, "void");
    } else {
        result = string_concat(result, params);
    }
    
    result = string_concat(result, ") {\n");
    
    expect(parser, TOK_LBRACE);
    result = string_concat(result, parse_block(parser, "    "));
    expect(parser, TOK_RBRACE);
    
    result = string_concat(result, "}\n\n");
    
    return result;
}

fn parse_program(parser: &mut Parser) -> String {
    let mut result = "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n";
    
    // Built-in functions
    result = string_concat(result, "// Built-in functions\n");
    result = string_concat(result, "long long string_len(const char* s) { return strlen(s); }\n");
    result = string_concat(result, "long long string_char_at(const char* s, long long i) { return s[i]; }\n");
    result = string_concat(result, "const char* string_from_char(long long c) { char* s = malloc(2); s[0] = c; s[1] = 0; return s; }\n");
    result = string_concat(result, "const char* string_concat(const char* a, const char* b) { char* s = malloc(strlen(a) + strlen(b) + 1); strcpy(s, a); strcat(s, b); return s; }\n");
    result = string_concat(result, "const char* int_to_string(long long n) { char* s = malloc(32); sprintf(s, \"%lld\", n); return s; }\n");
    result = string_concat(result, "int string_eq(const char* a, const char* b) { return strcmp(a, b) == 0; }\n");
    result = string_concat(result, "long long string_to_int(const char* s) { return atoll(s); }\n\n");
    
    // Forward declarations
    let mut forward_decls = "";
    let mut definitions = "";
    
    while parser.current.type_id != TOK_EOF {
        if parser.current.type_id == TOK_STRUCT {
            definitions = string_concat(definitions, parse_struct_definition(parser));
        } else if parser.current.type_id == TOK_ENUM {
            definitions = string_concat(definitions, parse_enum_definition(parser));
        } else if parser.current.type_id == TOK_FN {
            let func_def = parse_function_definition(parser);
            definitions = string_concat(definitions, func_def);
            
            // Extract forward declaration
            let mut i = 0;
            while i < string_len(func_def) && string_char_at(func_def, i) != 123 {
                forward_decls = string_concat(forward_decls, string_from_char(string_char_at(func_def, i)));
                i = i + 1;
            }
            forward_decls = string_concat(forward_decls, ";\n");
        } else {
            advance(parser);
        }
    }
    
    result = string_concat(result, forward_decls);
    result = string_concat(result, "\n");
    result = string_concat(result, definitions);
    
    // Add main if not present
    if find_function("main") < 0 {
        result = string_concat(result, "int main() {\n    return 0;\n}\n");
    }
    
    return result;
}

// ============ String Helpers ============
fn string_eq(a: String, b: String) -> bool {
    let len_a = string_len(a);
    let len_b = string_len(b);
    
    if len_a != len_b {
        return false;
    }
    
    let mut i = 0;
    while i < len_a {
        if string_char_at(a, i) != string_char_at(b, i) {
            return false;
        }
        i = i + 1;
    }
    
    return true;
}

fn string_to_int(s: String) -> i64 {
    let mut result = 0;
    let mut i = 0;
    let mut negative = false;
    
    if string_len(s) > 0 && string_char_at(s, 0) == 45 {
        negative = true;
        i = 1;
    }
    
    while i < string_len(s) {
        let ch = string_char_at(s, i);
        if ch >= 48 && ch <= 57 {
            result = result * 10 + (ch - 48);
        }
        i = i + 1;
    }
    
    if negative {
        return -result;
    }
    return result;
}

// ============ Main ============
fn main() {
    let test_program = "// Complete test program
struct Point {
    x: i64,
    y: i64
}

struct Rectangle {
    top_left: Point,
    width: i64,
    height: i64
}

enum Color {
    Red,
    Green,
    Blue
}

fn calculate_area(rect: Rectangle) -> i64 {
    return rect.width * rect.height;
}

fn distance_squared(p1: Point, p2: Point) -> i64 {
    let dx = p2.x - p1.x;
    let dy = p2.y - p1.y;
    return dx * dx + dy * dy;
}

fn factorial(n: i64) -> i64 {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

fn main() {
    // Test structs
    let p1: Point = Point { x: 10, y: 20 };
    let p2: Point = Point { x: 30, y: 40 };
    
    print(\"Distance squared:\");
    print_int(distance_squared(p1, p2));
    
    // Test arrays
    let nums: [i64; 5] = [1, 2, 3, 4, 5];
    let mut sum = 0;
    
    for i in 0..5 {
        sum = sum + nums[i];
    }
    
    print(\"Array sum:\");
    print_int(sum);
    
    // Test loops
    print(\"Fibonacci sequence:\");
    let mut a = 0;
    let mut b = 1;
    let mut i = 0;
    
    while i < 10 {
        print_int(a);
        let temp = a + b;
        a = b;
        b = temp;
        i = i + 1;
    }
    
    // Test recursion
    print(\"5! =\");
    print_int(factorial(5));
    
    // Test if/else
    if sum > 10 {
        print(\"Sum is greater than 10\");
    } else {
        print(\"Sum is 10 or less\");
    }
}
";

    print("Complete Palladium Compiler v14");
    print("================================");
    print("");
    print("Input program:");
    print("--------------");
    print(test_program);
    print("");
    
    let mut parser = create_parser(test_program);
    let compiled = parse_program(&mut parser);
    
    print("Compiled output:");
    print("----------------");
    print(compiled);
}