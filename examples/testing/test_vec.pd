// Comprehensive tests for Vec implementation

// Vec structure using parallel arrays
struct VecInt {
    data: [i64; 1000],     // Fixed-size backing array
    size: i64,             // Current number of elements
    capacity: i64,         // Current allocated capacity
}

// Create a new empty VecInt
fn vec_int_new() -> VecInt {
    let vec = VecInt {
        data: [0; 1000],
        size: 0,
        capacity: 16,
    };
    return vec;
}

// Get the current size
fn vec_int_len(vec: VecInt) -> i64 {
    return vec.size;
}

// Check if empty
fn vec_int_is_empty(vec: VecInt) -> bool {
    return vec.size == 0;
}

// Push an element to the end
fn vec_int_push(vec: mut VecInt, value: i64) -> VecInt {
    if vec.size >= 1000 {
        print("Error: Vec capacity exceeded");
        return vec;
    }
    
    vec.data[vec.size] = value;
    vec.size = vec.size + 1;
    return vec;
}

// Get element at index (unsafe - no bounds checking in return)
fn vec_int_get(vec: VecInt, index: i64) -> i64 {
    if index < 0 {
        print("Error: Index out of bounds");
        return -1;
    }
    if index >= vec.size {
        print("Error: Index out of bounds");
        return -1;
    }
    return vec.data[index];
}

// Set element at index
fn vec_int_set(vec: mut VecInt, index: i64, value: i64) -> VecInt {
    if index < 0 {
        print("Error: Index out of bounds");
        return vec;
    }
    if index >= vec.size {
        print("Error: Index out of bounds");
        return vec;
    }
    vec.data[index] = value;
    return vec;
}

// Pop last element (returns -1 if empty)
fn vec_int_pop(vec: mut VecInt) -> (VecInt, i64) {
    if vec.size == 0 {
        return (vec, -1);
    }
    vec.size = vec.size - 1;
    let value = vec.data[vec.size];
    return (vec, value);
}

// Clear all elements
fn vec_int_clear(vec: mut VecInt) -> VecInt {
    vec.size = 0;
    return vec;
}

// Find first occurrence of value
fn vec_int_find(vec: VecInt, value: i64) -> i64 {
    let mut i = 0;
    while i < vec.size {
        if vec.data[i] == value {
            return i;
        }
        i = i + 1;
    }
    return -1; // Not found
}

// Check if contains value
fn vec_int_contains(vec: VecInt, value: i64) -> bool {
    let index = vec_int_find(vec, value);
    return index != -1;
}

// Remove element at index (shifts remaining elements)
fn vec_int_remove(vec: mut VecInt, index: i64) -> VecInt {
    if index < 0 {
        print("Error: Index out of bounds");
        return vec;
    }
    if index >= vec.size {
        print("Error: Index out of bounds");
        return vec;
    }
    
    // Shift elements left
    let mut i = index;
    while i < vec.size - 1 {
        vec.data[i] = vec.data[i + 1];
        i = i + 1;
    }
    
    vec.size = vec.size - 1;
    return vec;
}

// Insert element at index (shifts remaining elements)
fn vec_int_insert(vec: mut VecInt, index: i64, value: i64) -> VecInt {
    if index < 0 {
        print("Error: Index out of bounds");
        return vec;
    }
    if index > vec.size {
        print("Error: Index out of bounds");
        return vec;
    }
    
    if vec.size >= 1000 {
        print("Error: Vec capacity exceeded");
        return vec;
    }
    
    // Shift elements right
    let mut i = vec.size;
    while i > index {
        vec.data[i] = vec.data[i - 1];
        i = i - 1;
    }
    
    vec.data[index] = value;
    vec.size = vec.size + 1;
    return vec;
}

// Reverse the vector in place
fn vec_int_reverse(vec: mut VecInt) -> VecInt {
    let mut i = 0;
    let mut j = vec.size - 1;
    
    while i < j {
        let temp = vec.data[i];
        vec.data[i] = vec.data[j];
        vec.data[j] = temp;
        i = i + 1;
        j = j - 1;
    }
    
    return vec;
}

// Sum all elements
fn vec_int_sum(vec: VecInt) -> i64 {
    let mut sum = 0;
    let mut i = 0;
    while i < vec.size {
        sum = sum + vec.data[i];
        i = i + 1;
    }
    return sum;
}

// Find minimum element (returns -1 if empty)
fn vec_int_min(vec: VecInt) -> i64 {
    if vec.size == 0 {
        return -1;
    }
    
    let mut min_val = vec.data[0];
    let mut i = 1;
    while i < vec.size {
        if vec.data[i] < min_val {
            min_val = vec.data[i];
        }
        i = i + 1;
    }
    return min_val;
}

// Find maximum element (returns -1 if empty)
fn vec_int_max(vec: VecInt) -> i64 {
    if vec.size == 0 {
        return -1;
    }
    
    let mut max_val = vec.data[0];
    let mut i = 1;
    while i < vec.size {
        if vec.data[i] > max_val {
            max_val = vec.data[i];
        }
        i = i + 1;
    }
    return max_val;
}

// Simple bubble sort
fn vec_int_sort(vec: mut VecInt) -> VecInt {
    let mut i = 0;
    while i < vec.size - 1 {
        let mut j = 0;
        while j < vec.size - i - 1 {
            if vec.data[j] > vec.data[j + 1] {
                // Swap
                let temp = vec.data[j];
                vec.data[j] = vec.data[j + 1];
                vec.data[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return vec;
}

// === Tests ===

fn test_vec_creation() {
    print("=== Testing Vec Creation ===");
    
    let mut vec = vec_int_new();
    
    if vec_int_len(vec) == 0 {
        print("Initial length: PASS");
    }
    
    if vec_int_is_empty(vec) {
        print("Initial empty: PASS");
    }
}

fn test_vec_push_pop() {
    print("\n=== Testing Push/Pop ===");
    
    let mut vec = vec_int_new();
    
    // Push elements
    vec = vec_int_push(vec, 10);
    vec = vec_int_push(vec, 20);
    vec = vec_int_push(vec, 30);
    
    if vec_int_len(vec) == 3 {
        print("Length after push: PASS");
    }
    
    if vec_int_get(vec, 0) == 10 {
        print("First element: PASS");
    }
    
    if vec_int_get(vec, 2) == 30 {
        print("Last element: PASS");
    }
    
    // Pop elements
    let (vec2, val1) = vec_int_pop(vec);
    vec = vec2;
    if val1 == 30 {
        print("Pop value: PASS");
    }
    
    if vec_int_len(vec) == 2 {
        print("Length after pop: PASS");
    }
}

fn test_vec_get_set() {
    print("\n=== Testing Get/Set ===");
    
    let mut vec = vec_int_new();
    vec = vec_int_push(vec, 100);
    vec = vec_int_push(vec, 200);
    vec = vec_int_push(vec, 300);
    
    // Test get
    if vec_int_get(vec, 1) == 200 {
        print("Get middle element: PASS");
    }
    
    // Test set
    vec = vec_int_set(vec, 1, 250);
    if vec_int_get(vec, 1) == 250 {
        print("Set element: PASS");
    }
    
    // Test bounds checking
    let invalid = vec_int_get(vec, 10);
    if invalid == -1 {
        print("Out of bounds get: PASS");
    }
}

fn test_vec_find_contains() {
    print("\n=== Testing Find/Contains ===");
    
    let mut vec = vec_int_new();
    vec = vec_int_push(vec, 10);
    vec = vec_int_push(vec, 20);
    vec = vec_int_push(vec, 30);
    vec = vec_int_push(vec, 20);
    
    // Test find
    let index = vec_int_find(vec, 20);
    if index == 1 {
        print("Find first occurrence: PASS");
    }
    
    let not_found = vec_int_find(vec, 40);
    if not_found == -1 {
        print("Find non-existent: PASS");
    }
    
    // Test contains
    if vec_int_contains(vec, 30) {
        print("Contains existing: PASS");
    }
    
    if vec_int_contains(vec, 40) == false {
        print("Contains non-existent: PASS");
    }
}

fn test_vec_insert_remove() {
    print("\n=== Testing Insert/Remove ===");
    
    let mut vec = vec_int_new();
    vec = vec_int_push(vec, 10);
    vec = vec_int_push(vec, 30);
    vec = vec_int_push(vec, 40);
    
    // Test insert
    vec = vec_int_insert(vec, 1, 20);
    if vec_int_get(vec, 1) == 20 {
        print("Insert middle: PASS");
    }
    
    if vec_int_len(vec) == 4 {
        print("Length after insert: PASS");
    }
    
    // Verify order
    if vec_int_get(vec, 0) == 10 {
        if vec_int_get(vec, 1) == 20 {
            if vec_int_get(vec, 2) == 30 {
                if vec_int_get(vec, 3) == 40 {
                    print("Order after insert: PASS");
                }
            }
        }
    }
    
    // Test remove
    vec = vec_int_remove(vec, 1);
    if vec_int_get(vec, 1) == 30 {
        print("Remove middle: PASS");
    }
    
    if vec_int_len(vec) == 3 {
        print("Length after remove: PASS");
    }
}

fn test_vec_reverse() {
    print("\n=== Testing Reverse ===");
    
    let mut vec = vec_int_new();
    vec = vec_int_push(vec, 1);
    vec = vec_int_push(vec, 2);
    vec = vec_int_push(vec, 3);
    vec = vec_int_push(vec, 4);
    
    vec = vec_int_reverse(vec);
    
    if vec_int_get(vec, 0) == 4 {
        if vec_int_get(vec, 1) == 3 {
            if vec_int_get(vec, 2) == 2 {
                if vec_int_get(vec, 3) == 1 {
                    print("Reverse: PASS");
                }
            }
        }
    }
}

fn test_vec_aggregates() {
    print("\n=== Testing Aggregates ===");
    
    let mut vec = vec_int_new();
    vec = vec_int_push(vec, 5);
    vec = vec_int_push(vec, 2);
    vec = vec_int_push(vec, 8);
    vec = vec_int_push(vec, 1);
    vec = vec_int_push(vec, 4);
    
    // Test sum
    let sum = vec_int_sum(vec);
    if sum == 20 {
        print("Sum: PASS");
    }
    
    // Test min
    let min_val = vec_int_min(vec);
    if min_val == 1 {
        print("Min: PASS");
    }
    
    // Test max
    let max_val = vec_int_max(vec);
    if max_val == 8 {
        print("Max: PASS");
    }
    
    // Test empty vec
    let empty = vec_int_new();
    if vec_int_min(empty) == -1 {
        print("Min empty: PASS");
    }
    
    if vec_int_max(empty) == -1 {
        print("Max empty: PASS");
    }
}

fn test_vec_sort() {
    print("\n=== Testing Sort ===");
    
    let mut vec = vec_int_new();
    vec = vec_int_push(vec, 5);
    vec = vec_int_push(vec, 2);
    vec = vec_int_push(vec, 8);
    vec = vec_int_push(vec, 1);
    vec = vec_int_push(vec, 4);
    
    vec = vec_int_sort(vec);
    
    if vec_int_get(vec, 0) == 1 {
        if vec_int_get(vec, 1) == 2 {
            if vec_int_get(vec, 2) == 4 {
                if vec_int_get(vec, 3) == 5 {
                    if vec_int_get(vec, 4) == 8 {
                        print("Sort: PASS");
                    }
                }
            }
        }
    }
}

fn test_vec_clear() {
    print("\n=== Testing Clear ===");
    
    let mut vec = vec_int_new();
    vec = vec_int_push(vec, 10);
    vec = vec_int_push(vec, 20);
    vec = vec_int_push(vec, 30);
    
    vec = vec_int_clear(vec);
    
    if vec_int_len(vec) == 0 {
        print("Clear length: PASS");
    }
    
    if vec_int_is_empty(vec) {
        print("Clear empty: PASS");
    }
}

// Test edge cases
fn test_vec_edge_cases() {
    print("\n=== Testing Edge Cases ===");
    
    let mut vec = vec_int_new();
    
    // Pop from empty
    let (vec2, val) = vec_int_pop(vec);
    if val == -1 {
        print("Pop empty: PASS");
    }
    
    // Single element operations
    vec = vec_int_push(vec2, 42);
    vec = vec_int_reverse(vec);
    if vec_int_get(vec, 0) == 42 {
        print("Reverse single: PASS");
    }
    
    vec = vec_int_sort(vec);
    if vec_int_get(vec, 0) == 42 {
        print("Sort single: PASS");
    }
}

// Real-world example: Fibonacci sequence
fn test_vec_fibonacci() {
    print("\n=== Testing Real Example: Fibonacci ===");
    
    let mut fib = vec_int_new();
    fib = vec_int_push(fib, 0);
    fib = vec_int_push(fib, 1);
    
    // Generate first 10 Fibonacci numbers
    let mut i = 2;
    while i < 10 {
        let a = vec_int_get(fib, i - 2);
        let b = vec_int_get(fib, i - 1);
        fib = vec_int_push(fib, a + b);
        i = i + 1;
    }
    
    // Check some values
    if vec_int_get(fib, 6) == 8 {
        print("Fibonacci 6th: PASS");
    }
    
    if vec_int_get(fib, 9) == 34 {
        print("Fibonacci 9th: PASS");
    }
    
    // Sum should be 88
    let sum = vec_int_sum(fib);
    if sum == 88 {
        print("Fibonacci sum: PASS");
    }
}

fn main() {
    print("=== Vec Implementation Tests ===\n");
    
    test_vec_creation();
    test_vec_push_pop();
    test_vec_get_set();
    test_vec_find_contains();
    test_vec_insert_remove();
    test_vec_reverse();
    test_vec_aggregates();
    test_vec_sort();
    test_vec_clear();
    test_vec_edge_cases();
    test_vec_fibonacci();
    
    print("\n=== All Vec tests complete ===");
}