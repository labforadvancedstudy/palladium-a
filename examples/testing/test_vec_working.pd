// Vec implementation without mutable parameters

struct VecInt {
    data: [i64; 100],  // Smaller size for testing
    size: i64,
}

fn vec_int_new() -> VecInt {
    let vec = VecInt {
        data: [0; 100],
        size: 0,
    };
    return vec;
}

fn vec_int_len(vec: VecInt) -> i64 {
    return vec.size;
}

fn vec_int_is_empty(vec: VecInt) -> bool {
    return vec.size == 0;
}

// Since we can't have mutable parameters, we modify and return
fn vec_int_push(vec: VecInt, value: i64) -> VecInt {
    let mut new_vec = vec;  // Make a mutable copy
    
    if new_vec.size >= 100 {
        print("Error: Vec capacity exceeded");
        return new_vec;
    }
    
    new_vec.data[new_vec.size] = value;
    new_vec.size = new_vec.size + 1;
    return new_vec;
}

fn vec_int_get(vec: VecInt, index: i64) -> i64 {
    if index < 0 {
        print("Error: Index out of bounds");
        return -1;
    }
    if index >= vec.size {
        print("Error: Index out of bounds");
        return -1;
    }
    return vec.data[index];
}

fn vec_int_sum(vec: VecInt) -> i64 {
    let mut sum = 0;
    let mut i = 0;
    while i < vec.size {
        sum = sum + vec.data[i];
        i = i + 1;
    }
    return sum;
}

// Test functions
fn test_vec_basic() {
    print("=== Testing Vec Basics ===");
    
    let mut vec = vec_int_new();
    
    if vec_int_len(vec) == 0 {
        print("Initial length: PASS");
    }
    
    if vec_int_is_empty(vec) {
        print("Initial empty: PASS");
    }
    
    // Push elements
    vec = vec_int_push(vec, 10);
    vec = vec_int_push(vec, 20);
    vec = vec_int_push(vec, 30);
    
    if vec_int_len(vec) == 3 {
        print("Length after push: PASS");
    }
    
    // Get elements
    if vec_int_get(vec, 0) == 10 {
        print("First element: PASS");
    }
    
    if vec_int_get(vec, 1) == 20 {
        print("Second element: PASS");
    }
    
    if vec_int_get(vec, 2) == 30 {
        print("Third element: PASS");
    }
    
    // Test sum
    if vec_int_sum(vec) == 60 {
        print("Sum: PASS");
    }
}

fn test_vec_bounds() {
    print("\n=== Testing Bounds Checking ===");
    
    let vec = vec_int_new();
    
    // Test negative index
    let val = vec_int_get(vec, -1);
    if val == -1 {
        print("Negative index: PASS");
    }
    
    // Test out of bounds
    let val2 = vec_int_get(vec, 10);
    if val2 == -1 {
        print("Out of bounds: PASS");
    }
}

fn test_vec_fibonacci() {
    print("\n=== Testing Fibonacci Sequence ===");
    
    let mut fib = vec_int_new();
    fib = vec_int_push(fib, 0);
    fib = vec_int_push(fib, 1);
    
    // Generate first 10 Fibonacci numbers
    let mut i = 2;
    while i < 10 {
        let a = vec_int_get(fib, i - 2);
        let b = vec_int_get(fib, i - 1);
        fib = vec_int_push(fib, a + b);
        i = i + 1;
    }
    
    // Check values
    if vec_int_get(fib, 0) == 0 {
        print("Fib 0: PASS");
    }
    
    if vec_int_get(fib, 1) == 1 {
        print("Fib 1: PASS");
    }
    
    if vec_int_get(fib, 5) == 5 {
        print("Fib 5: PASS");
    }
    
    if vec_int_get(fib, 9) == 34 {
        print("Fib 9: PASS");
    }
}

fn main() {
    print("=== Vec Implementation Tests ===\n");
    
    test_vec_basic();
    test_vec_bounds();
    test_vec_fibonacci();
    
    print("\n=== All tests complete ===");
}