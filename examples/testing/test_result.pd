// Comprehensive tests for Result types

// Test StringResult
fn test_string_result() {
    print("=== Testing StringResult ===");
    
    // Test Ok variant
    let ok_result = StringResult::Ok("Hello, Result!");
    if string_result_is_ok(ok_result) {
        print("is_ok test: PASS");
    } else {
        print("is_ok test: FAIL");
    }
    
    let value = string_result_unwrap(ok_result);
    if string_eq(value, "Hello, Result!") {
        print("unwrap test: PASS");
    } else {
        print("unwrap test: FAIL");
    }
    
    // Test Err variant
    let err_result = StringResult::Err("Something went wrong");
    if string_result_is_ok(err_result) {
        print("is_err test: FAIL");
    } else {
        print("is_err test: PASS");
    }
    
    let default_val = string_result_unwrap_or(err_result, "default");
    if string_eq(default_val, "default") {
        print("unwrap_or test: PASS");
    } else {
        print("unwrap_or test: FAIL");
    }
    
    // Test expect
    let ok_for_expect = StringResult::Ok("expected value");
    let expected = string_result_expect(ok_for_expect, "This should not print");
    if string_eq(expected, "expected value") {
        print("expect on Ok: PASS");
    }
}

// Test IntResult
fn test_int_result() {
    print("\n=== Testing IntResult ===");
    
    // Test Ok variant
    let ok_result = IntResult::Ok(42);
    if int_result_is_ok(ok_result) {
        print("is_ok test: PASS");
    }
    
    let value = int_result_unwrap(ok_result);
    if value == 42 {
        print("unwrap test: PASS");
    }
    
    // Test Err variant
    let err_result = IntResult::Err("Invalid number");
    let default_val = int_result_unwrap_or(err_result, 0);
    if default_val == 0 {
        print("unwrap_or test: PASS");
    }
}

// Test parse_int function
fn test_parse_int() {
    print("\n=== Testing parse_int ===");
    
    // Valid positive number
    let result1 = parse_int("123");
    if int_result_is_ok(result1) {
        let val = int_result_unwrap(result1);
        if val == 123 {
            print("Positive number: PASS");
        }
    }
    
    // Valid negative number
    let result2 = parse_int("-456");
    if int_result_is_ok(result2) {
        let val = int_result_unwrap(result2);
        if val == -456 {
            print("Negative number: PASS");
        }
    }
    
    // Invalid: empty string
    let result3 = parse_int("");
    if int_result_is_ok(result3) == false {
        print("Empty string rejection: PASS");
    }
    
    // Invalid: just minus
    let result4 = parse_int("-");
    if int_result_is_ok(result4) == false {
        print("Just minus rejection: PASS");
    }
    
    // Invalid: contains letters
    let result5 = parse_int("12a3");
    if int_result_is_ok(result5) == false {
        print("Invalid character rejection: PASS");
    }
    
    // Edge case: zero
    let result6 = parse_int("0");
    if int_result_is_ok(result6) {
        let val = int_result_unwrap(result6);
        if val == 0 {
            print("Zero parsing: PASS");
        }
    }
}

// Test file operations
fn test_file_operations() {
    print("\n=== Testing File Operations ===");
    
    // Test nonexistent file
    let result1 = safe_file_open("nonexistent.txt");
    match result1 {
        FileResult::Err(msg) => {
            print("Nonexistent file error: PASS");
            print(msg);
        }
        FileResult::Ok(_) => print("Nonexistent file error: FAIL"),
    }
    
    // Test reading existing file
    let result2 = safe_file_read("examples/hello.pd");
    match result2 {
        StringResult::Ok(content) => {
            if string_len(content) > 0 {
                print("File read success: PASS");
            }
        }
        StringResult::Err(msg) => {
            print("File read failed:");
            print(msg);
        }
    }
}

// Test compile_file function
fn test_compile_file() {
    print("\n=== Testing compile_file ===");
    
    // Test with existing file
    let result1 = compile_file("examples/hello.pd");
    if compile_result_is_success(result1) {
        print("Compile success: PASS");
        match result1 {
            CompileResult::Success(output) => {
                if string_len(output) > 0 {
                    print("Generated output exists: PASS");
                }
            }
            _ => {},
        }
    }
    
    // Test with nonexistent file
    let result2 = compile_file("nonexistent.pd");
    match result2 {
        CompileResult::Error(msg) => {
            print("Compile error handling: PASS");
            print(msg);
        }
        CompileResult::Success(_) => print("Compile error handling: FAIL"),
    }
}

// Test chaining operations
fn test_chaining() {
    print("\n=== Testing Operation Chaining ===");
    
    // Create a test file with a number
    let test_file = "test_number.txt";
    let handle = file_open(test_file);
    if handle != -1 {
        file_write(handle, "42");
        file_close(handle);
        
        // Try to read and parse
        let result = read_and_parse_number(test_file);
        match result {
            IntResult::Ok(num) => {
                if num == 42 {
                    print("Chain operation: PASS");
                }
            }
            IntResult::Err(msg) => {
                print("Chain operation failed:");
                print(msg);
            }
        }
    }
}

fn main() {
    print("=== Result Type Comprehensive Tests ===\n");
    
    test_string_result();
    test_int_result();
    test_parse_int();
    test_file_operations();
    test_compile_file();
    test_chaining();
    
    print("\n=== All Result tests complete ===");
}