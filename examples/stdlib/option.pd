// Standard library Option type implementation
// For representing nullable values

// Option type for any value that might not exist
enum OptionString {
    Some(String),
    None,
}

enum OptionInt {
    Some(i64),
    None,
}

enum OptionBool {
    Some(bool),
    None,
}

// Helper functions for OptionString
fn option_string_is_some(opt: OptionString) -> bool {
    match opt {
        OptionString::Some(_) => true,
        OptionString::None => false,
    }
}

fn option_string_is_none(opt: OptionString) -> bool {
    match opt {
        OptionString::Some(_) => false,
        OptionString::None => true,
    }
}

fn option_string_unwrap(opt: OptionString) -> String {
    match opt {
        OptionString::Some(value) => value,
        OptionString::None => {
            print("Error: unwrap() called on None");
            return "";
        }
    }
}

fn option_string_unwrap_or(opt: OptionString, default: String) -> String {
    match opt {
        OptionString::Some(value) => value,
        OptionString::None => default,
    }
}

fn option_string_map_or(opt: OptionString, default: String, f: fn(String) -> String) -> String {
    match opt {
        OptionString::Some(value) => f(value),
        OptionString::None => default,
    }
}

// Helper functions for OptionInt
fn option_int_is_some(opt: OptionInt) -> bool {
    match opt {
        OptionInt::Some(_) => true,
        OptionInt::None => false,
    }
}

fn option_int_is_none(opt: OptionInt) -> bool {
    match opt {
        OptionInt::Some(_) => false,
        OptionInt::None => true,
    }
}

fn option_int_unwrap(opt: OptionInt) -> i64 {
    match opt {
        OptionInt::Some(value) => value,
        OptionInt::None => {
            print("Error: unwrap() called on None");
            return -1;
        }
    }
}

fn option_int_unwrap_or(opt: OptionInt, default: i64) -> i64 {
    match opt {
        OptionInt::Some(value) => value,
        OptionInt::None => default,
    }
}

// Helper functions for OptionBool
fn option_bool_is_some(opt: OptionBool) -> bool {
    match opt {
        OptionBool::Some(_) => true,
        OptionBool::None => false,
    }
}

fn option_bool_is_none(opt: OptionBool) -> bool {
    match opt {
        OptionBool::Some(_) => false,
        OptionBool::None => true,
    }
}

fn option_bool_unwrap(opt: OptionBool) -> bool {
    match opt {
        OptionBool::Some(value) => value,
        OptionBool::None => {
            print("Error: unwrap() called on None");
            return false;
        }
    }
}

fn option_bool_unwrap_or(opt: OptionBool, default: bool) -> bool {
    match opt {
        OptionBool::Some(value) => value,
        OptionBool::None => default,
    }
}

// Utility functions using Option

// Find character in string, returns OptionInt with position
fn string_find_char(s: String, target: i64) -> OptionInt {
    let len = string_len(s);
    let mut i = 0;
    
    while i < len {
        let c = string_char_at(s, i);
        if c == target {
            return OptionInt::Some(i);
        }
        i = i + 1;
    }
    
    return OptionInt::None;
}

// Find substring in string, returns OptionInt with position
fn string_find(haystack: String, needle: String) -> OptionInt {
    let hay_len = string_len(haystack);
    let needle_len = string_len(needle);
    
    if needle_len == 0 {
        return OptionInt::Some(0);
    }
    
    if needle_len > hay_len {
        return OptionInt::None;
    }
    
    let mut i = 0;
    while i <= hay_len - needle_len {
        let substr = string_substring(haystack, i, i + needle_len);
        if string_eq(substr, needle) {
            return OptionInt::Some(i);
        }
        i = i + 1;
    }
    
    return OptionInt::None;
}

// Get first line from string
fn string_first_line(s: String) -> OptionString {
    let len = string_len(s);
    if len == 0 {
        return OptionString::None;
    }
    
    let newline_pos = string_find_char(s, 10); // 10 is '\n'
    match newline_pos {
        OptionInt::Some(pos) => {
            let line = string_substring(s, 0, pos);
            return OptionString::Some(line);
        }
        OptionInt::None => {
            return OptionString::Some(s);
        }
    }
}

// Parse integer with detailed error info
fn parse_int_safe(s: String) -> OptionInt {
    let len = string_len(s);
    if len == 0 {
        return OptionInt::None;
    }
    
    let mut i = 0;
    let first_char = string_char_at(s, 0);
    
    if first_char == 45 { // '-'
        i = 1;
        if len == 1 {
            return OptionInt::None;
        }
    }
    
    // Validate all digits
    while i < len {
        let c = string_char_at(s, i);
        if char_is_digit(c) == false {
            return OptionInt::None;
        }
        i = i + 1;
    }
    
    let num = string_to_int(s);
    return OptionInt::Some(num);
}

// Get environment variable (mock implementation)
fn get_env(name: String) -> OptionString {
    // In a real implementation, this would check environment
    if string_eq(name, "HOME") {
        return OptionString::Some("/home/user");
    }
    if string_eq(name, "PATH") {
        return OptionString::Some("/usr/bin:/bin");
    }
    return OptionString::None;
}

// Dictionary lookup (simple mock)
fn dict_get(key: String) -> OptionString {
    if string_eq(key, "version") {
        return OptionString::Some("1.0.0");
    }
    if string_eq(key, "author") {
        return OptionString::Some("Palladium Team");
    }
    return OptionString::None;
}