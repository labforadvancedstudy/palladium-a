// HashMap implementation in Palladium
// Using parallel arrays to work around array-of-structs limitation
// This is a crucial data structure for bootstrapping!

struct HashMap {
    keys: [String; 100],      // Keys array
    values: [i64; 100],       // Values array  
    occupied: [bool; 100],    // Which slots are occupied
    size: i64,                // Number of entries
}

// Simple hash function for strings
fn hash_string(s: String) -> i64 {
    let mut hash = 0;
    let len = string_len(s);
    
    for i in 0..len {
        let ch = string_char_at(s, i);
        hash = (hash * 31 + ch) % 100;
    }
    
    return hash;
}

// Create a new empty HashMap
fn hashmap_new() -> HashMap {
    // Initialize arrays
    let empty_keys = [""; 100];
    let empty_values = [0; 100];
    let empty_occupied = [false; 100];
    
    return HashMap {
        keys: empty_keys,
        values: empty_values,
        occupied: empty_occupied,
        size: 0
    };
}

// Insert a key-value pair
fn hashmap_insert(map: HashMap, key: String, value: i64) -> HashMap {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    let mut new_map = map;
    
    // Linear probing to find empty slot or existing key
    let mut found = false;
    let mut attempts = 0;
    
    while attempts < 100 && found == false {
        if new_map.occupied[idx] == false || string_eq(new_map.keys[idx], key) {
            found = true;
        } else {
            idx = (idx + 1) % 100;
            attempts = attempts + 1;
        }
    }
    
    if found {
        // Update or insert
        if new_map.occupied[idx] == false {
            new_map.size = new_map.size + 1;
        }
        
        new_map.keys[idx] = key;
        new_map.values[idx] = value;
        new_map.occupied[idx] = true;
    }
    
    return new_map;
}

// Get a value by key
fn hashmap_get(map: HashMap, key: String) -> i64 {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 100 {
        if map.occupied[idx] && string_eq(map.keys[idx], key) {
            return map.values[idx];
        }
        
        if map.occupied[idx] == false {
            // Key not found
            return -1;  // TODO: Should use Option type
        }
        
        idx = (idx + 1) % 100;
        attempts = attempts + 1;
    }
    
    return -1;  // Not found
}

// Check if key exists
fn hashmap_contains(map: HashMap, key: String) -> bool {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 100 {
        if map.occupied[idx] && string_eq(map.keys[idx], key) {
            return true;
        }
        
        if map.occupied[idx] == false {
            return false;
        }
        
        idx = (idx + 1) % 100;
        attempts = attempts + 1;
    }
    
    return false;
}

// Remove a key
fn hashmap_remove(map: HashMap, key: String) -> HashMap {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    let mut new_map = map;
    let mut attempts = 0;
    
    while attempts < 100 {
        if new_map.occupied[idx] && string_eq(new_map.keys[idx], key) {
            // Mark as not occupied
            new_map.occupied[idx] = false;
            new_map.size = new_map.size - 1;
            
            // TODO: Should rehash entries after this position
            // For simplicity, we're leaving tombstones
            
            return new_map;
        }
        
        if new_map.occupied[idx] == false {
            // Key not found
            return new_map;
        }
        
        idx = (idx + 1) % 100;
        attempts = attempts + 1;
    }
    
    return new_map;
}

// Get the size of the HashMap
fn hashmap_size(map: HashMap) -> i64 {
    return map.size;
}

// Test the HashMap implementation
fn test_hashmap() {
    print("=== HashMap Implementation Tests ===\n");
    
    // Test 1: Basic insertion and retrieval
    print("Test 1: Basic operations");
    let mut map = hashmap_new();
    
    map = hashmap_insert(map, "hello", 42);
    map = hashmap_insert(map, "world", 100);
    map = hashmap_insert(map, "foo", 123);
    
    let val1 = hashmap_get(map, "hello");
    let val2 = hashmap_get(map, "world");
    let val3 = hashmap_get(map, "foo");
    
    if val1 == 42 && val2 == 100 && val3 == 123 {
        print("âœ“ Basic insertion and retrieval works");
    } else {
        print("âœ— Basic operations failed");
        print_int(val1);
        print_int(val2);
        print_int(val3);
    }
    
    // Test 2: Size tracking
    if hashmap_size(map) == 3 {
        print("âœ“ Size tracking works");
    } else {
        print("âœ— Size tracking failed");
        print_int(hashmap_size(map));
    }
    
    // Test 3: Contains check
    if hashmap_contains(map, "hello") && hashmap_contains(map, "world") {
        if hashmap_contains(map, "notfound") == false {
            print("âœ“ Contains check works");
        } else {
            print("âœ— Contains returned true for non-existent key");
        }
    } else {
        print("âœ— Contains check failed");
    }
    
    // Test 4: Update existing key
    map = hashmap_insert(map, "hello", 999);
    let updated = hashmap_get(map, "hello");
    
    if updated == 999 && hashmap_size(map) == 3 {
        print("âœ“ Updating existing key works");
    } else {
        print("âœ— Update failed");
        print_int(updated);
        print_int(hashmap_size(map));
    }
    
    // Test 5: Removal
    map = hashmap_remove(map, "world");
    
    if hashmap_contains(map, "world") == false && hashmap_size(map) == 2 {
        print("âœ“ Removal works");
    } else {
        print("âœ— Removal failed");
    }
    
    // Test 6: Hash collision handling
    print("\nTest 2: Collision handling");
    
    // These might collide depending on hash function
    map = hashmap_insert(map, "key1", 10);
    map = hashmap_insert(map, "key2", 20);
    map = hashmap_insert(map, "key3", 30);
    map = hashmap_insert(map, "key4", 40);
    map = hashmap_insert(map, "key5", 50);
    
    let collision_test = 
        hashmap_get(map, "key1") == 10 &&
        hashmap_get(map, "key2") == 20 &&
        hashmap_get(map, "key3") == 30 &&
        hashmap_get(map, "key4") == 40 &&
        hashmap_get(map, "key5") == 50;
    
    if collision_test {
        print("âœ“ Collision handling works");
    } else {
        print("âœ— Collision handling failed");
    }
    
    print("\n=== HashMap Tests Complete ===");
    print("HashMap is functional! This enables symbol tables! ðŸŽ‰");
}

// Demonstrate practical usage
fn demo_symbol_table() {
    print("\n=== Symbol Table Demo ===");
    
    let mut symbols = hashmap_new();
    
    // Add some variables
    symbols = hashmap_insert(symbols, "x", 1);      // Variable IDs
    symbols = hashmap_insert(symbols, "y", 2);
    symbols = hashmap_insert(symbols, "count", 3);
    symbols = hashmap_insert(symbols, "result", 4);
    
    // Add some functions  
    symbols = hashmap_insert(symbols, "main", 100);
    symbols = hashmap_insert(symbols, "print", 101);
    symbols = hashmap_insert(symbols, "calculate", 102);
    
    print("Symbol table created with:");
    print_int(hashmap_size(symbols));
    print("entries");
    
    // Lookup symbols
    if hashmap_contains(symbols, "x") {
        print("Found variable 'x' with ID:");
        print_int(hashmap_get(symbols, "x"));
    }
    
    if hashmap_contains(symbols, "main") {
        print("Found function 'main' with ID:");
        print_int(hashmap_get(symbols, "main"));
    }
    
    print("\nThis is exactly what we need for a compiler!");
}

fn main() {
    test_hashmap();
    demo_symbol_table();
}