// Ultra-simple HashMap implementation in Palladium
// Working around struct limitations by using module-level arrays
// This demonstrates we can still build core data structures!

// Global storage for a single hashmap (100 buckets)
let g_keys: [String; 100] = [""; 100];
let g_values: [i64; 100] = [0; 100];  
let g_occupied: [bool; 100] = [false; 100];
let mut g_size: i64 = 0;

// Simple hash function for strings
fn hash_string(s: String) -> i64 {
    let mut hash = 0;
    let len = string_len(s);
    
    for i in 0..len {
        let ch = string_char_at(s, i);
        hash = (hash * 31 + ch) % 100;
    }
    
    return hash;
}

// Clear the hashmap
fn hashmap_clear() {
    for i in 0..100 {
        g_keys[i] = "";
        g_values[i] = 0;
        g_occupied[i] = false;
    }
    g_size = 0;
}

// Insert a key-value pair
fn hashmap_insert(key: String, value: i64) {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    
    // Linear probing to find empty slot or existing key
    let mut found = false;
    let mut attempts = 0;
    
    while attempts < 100 && found == false {
        if g_occupied[idx] == false || string_eq(g_keys[idx], key) {
            found = true;
        } else {
            idx = (idx + 1) % 100;
            attempts = attempts + 1;
        }
    }
    
    if found {
        // Update or insert
        if g_occupied[idx] == false {
            g_size = g_size + 1;
        }
        
        g_keys[idx] = key;
        g_values[idx] = value;
        g_occupied[idx] = true;
    }
}

// Get a value by key
fn hashmap_get(key: String) -> i64 {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 100 {
        if g_occupied[idx] && string_eq(g_keys[idx], key) {
            return g_values[idx];
        }
        
        if g_occupied[idx] == false {
            // Key not found
            return -1;  // TODO: Should use Option type
        }
        
        idx = (idx + 1) % 100;
        attempts = attempts + 1;
    }
    
    return -1;  // Not found
}

// Check if key exists
fn hashmap_contains(key: String) -> bool {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 100 {
        if g_occupied[idx] && string_eq(g_keys[idx], key) {
            return true;
        }
        
        if g_occupied[idx] == false {
            return false;
        }
        
        idx = (idx + 1) % 100;
        attempts = attempts + 1;
    }
    
    return false;
}

// Remove a key
fn hashmap_remove(key: String) {
    let hash_idx = hash_string(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 100 {
        if g_occupied[idx] && string_eq(g_keys[idx], key) {
            // Mark as not occupied
            g_occupied[idx] = false;
            g_size = g_size - 1;
            
            // TODO: Should rehash entries after this position
            // For simplicity, we're leaving tombstones
            
            return;
        }
        
        if g_occupied[idx] == false {
            // Key not found
            return;
        }
        
        idx = (idx + 1) % 100;
        attempts = attempts + 1;
    }
}

// Get the size of the HashMap
fn hashmap_size() -> i64 {
    return g_size;
}

// Test the HashMap implementation
fn test_hashmap() {
    print("=== Ultra-Simple HashMap Tests ===\n");
    
    // Test 1: Basic insertion and retrieval
    print("Test 1: Basic operations");
    hashmap_clear();
    
    hashmap_insert("hello", 42);
    hashmap_insert("world", 100);
    hashmap_insert("foo", 123);
    
    let val1 = hashmap_get("hello");
    let val2 = hashmap_get("world");
    let val3 = hashmap_get("foo");
    
    if val1 == 42 && val2 == 100 && val3 == 123 {
        print("âœ“ Basic insertion and retrieval works");
    } else {
        print("âœ— Basic operations failed");
        print_int(val1);
        print_int(val2);
        print_int(val3);
    }
    
    // Test 2: Size tracking
    if hashmap_size() == 3 {
        print("âœ“ Size tracking works");
    } else {
        print("âœ— Size tracking failed");
        print_int(hashmap_size());
    }
    
    // Test 3: Contains check
    if hashmap_contains("hello") && hashmap_contains("world") {
        if hashmap_contains("notfound") == false {
            print("âœ“ Contains check works");
        } else {
            print("âœ— Contains returned true for non-existent key");
        }
    } else {
        print("âœ— Contains check failed");
    }
    
    // Test 4: Update existing key
    hashmap_insert("hello", 999);
    let updated = hashmap_get("hello");
    
    if updated == 999 && hashmap_size() == 3 {
        print("âœ“ Updating existing key works");
    } else {
        print("âœ— Update failed");
        print_int(updated);
        print_int(hashmap_size());
    }
    
    // Test 5: Removal
    hashmap_remove("world");
    
    if hashmap_contains("world") == false && hashmap_size() == 2 {
        print("âœ“ Removal works");
    } else {
        print("âœ— Removal failed");
    }
    
    // Test 6: Hash collision handling
    print("\nTest 2: Collision handling");
    
    // These might collide depending on hash function
    hashmap_insert("key1", 10);
    hashmap_insert("key2", 20);
    hashmap_insert("key3", 30);
    hashmap_insert("key4", 40);
    hashmap_insert("key5", 50);
    
    let collision_test = 
        hashmap_get("key1") == 10 &&
        hashmap_get("key2") == 20 &&
        hashmap_get("key3") == 30 &&
        hashmap_get("key4") == 40 &&
        hashmap_get("key5") == 50;
    
    if collision_test {
        print("âœ“ Collision handling works");
    } else {
        print("âœ— Collision handling failed");
    }
    
    print("\n=== HashMap Tests Complete ===");
    print("HashMap is functional! This enables symbol tables! ðŸŽ‰");
}

// Demonstrate practical usage
fn demo_symbol_table() {
    print("\n=== Symbol Table Demo ===");
    
    hashmap_clear();
    
    // Add some variables
    hashmap_insert("x", 1);      // Variable IDs
    hashmap_insert("y", 2);
    hashmap_insert("count", 3);
    hashmap_insert("result", 4);
    
    // Add some functions  
    hashmap_insert("main", 100);
    hashmap_insert("print", 101);
    hashmap_insert("calculate", 102);
    
    print("Symbol table created with:");
    print_int(hashmap_size());
    print("entries");
    
    // Lookup symbols
    if hashmap_contains("x") {
        print("Found variable 'x' with ID:");
        print_int(hashmap_get("x"));
    }
    
    if hashmap_contains("main") {
        print("Found function 'main' with ID:");
        print_int(hashmap_get("main"));
    }
    
    print("\nThis is exactly what we need for a compiler!");
}

fn main() {
    test_hashmap();
    demo_symbol_table();
}