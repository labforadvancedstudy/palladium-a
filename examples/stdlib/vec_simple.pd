// Simple Vec (dynamic array) implementation
// Using heap allocation simulation with fixed-size arrays

// Constants for Vec implementation
let VEC_MAX_SIZE: i64 = 1000;
let VEC_INITIAL_CAPACITY: i64 = 16;

// Vec structure using parallel arrays
struct VecInt {
    data: [i64; 1000],     // Fixed-size backing array
    size: i64,             // Current number of elements
    capacity: i64,         // Current allocated capacity
}

// Create a new empty VecInt
fn vec_int_new() -> VecInt {
    let vec = VecInt {
        data: [0; 1000],
        size: 0,
        capacity: VEC_INITIAL_CAPACITY,
    };
    return vec;
}

// Get the current size
fn vec_int_len(vec: VecInt) -> i64 {
    return vec.size;
}

// Check if empty
fn vec_int_is_empty(vec: VecInt) -> bool {
    return vec.size == 0;
}

// Push an element to the end
fn vec_int_push(vec: mut VecInt, value: i64) -> VecInt {
    if vec.size >= VEC_MAX_SIZE {
        print("Error: Vec capacity exceeded");
        return vec;
    }
    
    vec.data[vec.size] = value;
    vec.size = vec.size + 1;
    return vec;
}

// Get element at index (unsafe - no bounds checking in return)
fn vec_int_get(vec: VecInt, index: i64) -> i64 {
    if index < 0 || index >= vec.size {
        print("Error: Index out of bounds");
        return -1;
    }
    return vec.data[index];
}

// Set element at index
fn vec_int_set(vec: mut VecInt, index: i64, value: i64) -> VecInt {
    if index < 0 || index >= vec.size {
        print("Error: Index out of bounds");
        return vec;
    }
    vec.data[index] = value;
    return vec;
}

// Pop last element (returns -1 if empty)
fn vec_int_pop(vec: mut VecInt) -> (VecInt, i64) {
    if vec.size == 0 {
        return (vec, -1);
    }
    vec.size = vec.size - 1;
    let value = vec.data[vec.size];
    return (vec, value);
}

// Clear all elements
fn vec_int_clear(vec: mut VecInt) -> VecInt {
    vec.size = 0;
    return vec;
}

// Find first occurrence of value
fn vec_int_find(vec: VecInt, value: i64) -> i64 {
    let mut i = 0;
    while i < vec.size {
        if vec.data[i] == value {
            return i;
        }
        i = i + 1;
    }
    return -1; // Not found
}

// Check if contains value
fn vec_int_contains(vec: VecInt, value: i64) -> bool {
    let index = vec_int_find(vec, value);
    return index != -1;
}

// Remove element at index (shifts remaining elements)
fn vec_int_remove(vec: mut VecInt, index: i64) -> VecInt {
    if index < 0 || index >= vec.size {
        print("Error: Index out of bounds");
        return vec;
    }
    
    // Shift elements left
    let mut i = index;
    while i < vec.size - 1 {
        vec.data[i] = vec.data[i + 1];
        i = i + 1;
    }
    
    vec.size = vec.size - 1;
    return vec;
}

// Insert element at index (shifts remaining elements)
fn vec_int_insert(vec: mut VecInt, index: i64, value: i64) -> VecInt {
    if index < 0 || index > vec.size {
        print("Error: Index out of bounds");
        return vec;
    }
    
    if vec.size >= VEC_MAX_SIZE {
        print("Error: Vec capacity exceeded");
        return vec;
    }
    
    // Shift elements right
    let mut i = vec.size;
    while i > index {
        vec.data[i] = vec.data[i - 1];
        i = i - 1;
    }
    
    vec.data[index] = value;
    vec.size = vec.size + 1;
    return vec;
}

// Reverse the vector in place
fn vec_int_reverse(vec: mut VecInt) -> VecInt {
    let mut i = 0;
    let mut j = vec.size - 1;
    
    while i < j {
        let temp = vec.data[i];
        vec.data[i] = vec.data[j];
        vec.data[j] = temp;
        i = i + 1;
        j = j - 1;
    }
    
    return vec;
}

// Sum all elements
fn vec_int_sum(vec: VecInt) -> i64 {
    let mut sum = 0;
    let mut i = 0;
    while i < vec.size {
        sum = sum + vec.data[i];
        i = i + 1;
    }
    return sum;
}

// Find minimum element (returns -1 if empty)
fn vec_int_min(vec: VecInt) -> i64 {
    if vec.size == 0 {
        return -1;
    }
    
    let mut min_val = vec.data[0];
    let mut i = 1;
    while i < vec.size {
        if vec.data[i] < min_val {
            min_val = vec.data[i];
        }
        i = i + 1;
    }
    return min_val;
}

// Find maximum element (returns -1 if empty)
fn vec_int_max(vec: VecInt) -> i64 {
    if vec.size == 0 {
        return -1;
    }
    
    let mut max_val = vec.data[0];
    let mut i = 1;
    while i < vec.size {
        if vec.data[i] > max_val {
            max_val = vec.data[i];
        }
        i = i + 1;
    }
    return max_val;
}

// Simple bubble sort
fn vec_int_sort(vec: mut VecInt) -> VecInt {
    let mut i = 0;
    while i < vec.size - 1 {
        let mut j = 0;
        while j < vec.size - i - 1 {
            if vec.data[j] > vec.data[j + 1] {
                // Swap
                let temp = vec.data[j];
                vec.data[j] = vec.data[j + 1];
                vec.data[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return vec;
}

// Print vector contents
fn vec_int_print(vec: VecInt) {
    print("[");
    let mut i = 0;
    while i < vec.size {
        print_int(vec.data[i]);
        if i < vec.size - 1 {
            print(", ");
        }
        i = i + 1;
    }
    print("]");
}