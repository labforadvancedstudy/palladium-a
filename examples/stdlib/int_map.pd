// Ultra-simple integer-to-integer map using fixed size arrays
// Working around current language limitations

// Hash function for integers
fn hash_int(key: i64) -> i64 {
    let hash = key % 50;
    if hash < 0 {
        return 0 - hash;
    }
    return hash;
}

// Find the index for a key (or where to insert it)
fn find_slot(keys: [i64; 50], occupied: [bool; 50], key: i64) -> i64 {
    let hash_idx = hash_int(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 50 {
        if occupied[idx] == false || keys[idx] == key {
            return idx;
        }
        idx = (idx + 1) % 50;
        attempts = attempts + 1;
    }
    
    return -1; // Table full
}

// Test the simple map implementation
fn test_int_map() {
    print("=== Integer Map Tests ===\n");
    
    // Initialize arrays
    let mut keys: [i64; 50] = [0; 50];
    let mut values: [i64; 50] = [0; 50];
    let mut occupied: [bool; 50] = [false; 50];
    let mut size = 0;
    
    // Test 1: Basic insertion
    print("Test 1: Basic operations");
    
    // Insert (42, 100)
    let slot1 = find_slot(keys, occupied, 42);
    if slot1 >= 0 {
        if occupied[slot1] == false {
            size = size + 1;
        }
        keys[slot1] = 42;
        values[slot1] = 100;
        occupied[slot1] = true;
    }
    
    // Insert (17, 200)
    let slot2 = find_slot(keys, occupied, 17);
    if slot2 >= 0 {
        if occupied[slot2] == false {
            size = size + 1;
        }
        keys[slot2] = 17;
        values[slot2] = 200;
        occupied[slot2] = true;
    }
    
    // Insert (99, 300)
    let slot3 = find_slot(keys, occupied, 99);
    if slot3 >= 0 {
        if occupied[slot3] == false {
            size = size + 1;
        }
        keys[slot3] = 99;
        values[slot3] = 300;
        occupied[slot3] = true;
    }
    
    // Retrieve values
    let get1 = find_slot(keys, occupied, 42);
    let get2 = find_slot(keys, occupied, 17);
    let get3 = find_slot(keys, occupied, 99);
    
    if get1 >= 0 && get2 >= 0 && get3 >= 0 {
        if values[get1] == 100 && values[get2] == 200 && values[get3] == 300 {
            print("âœ“ Basic insertion and retrieval works");
        } else {
            print("âœ— Basic operations failed");
        }
    } else {
        print("âœ— Failed to find keys");
    }
    
    // Test 2: Size tracking
    if size == 3 {
        print("âœ“ Size tracking works");
    } else {
        print("âœ— Size tracking failed");
        print_int(size);
    }
    
    // Test 3: Update existing key
    let update_slot = find_slot(keys, occupied, 42);
    if update_slot >= 0 {
        values[update_slot] = 999;
        let check_slot = find_slot(keys, occupied, 42);
        if check_slot >= 0 && values[check_slot] == 999 {
            print("âœ“ Updating existing key works");
        } else {
            print("âœ— Update failed");
        }
    }
    
    // Test 4: Non-existent key
    let not_found = find_slot(keys, occupied, 12345);
    if not_found >= 0 && occupied[not_found] == false {
        print("âœ“ Non-existent key handling works");
    } else if not_found < 0 {
        print("âœ— Table appears full (shouldn't be)");
    } else {
        print("âœ— Found non-existent key");
    }
    
    // Test 5: Collision handling
    print("\nTest 2: Collision handling");
    
    // Force some collisions (50 and 100 both hash to 0)
    let slot_50 = find_slot(keys, occupied, 50);
    if slot_50 >= 0 {
        keys[slot_50] = 50;
        values[slot_50] = 1000;
        occupied[slot_50] = true;
        size = size + 1;
    }
    
    let slot_100 = find_slot(keys, occupied, 100);
    if slot_100 >= 0 {
        keys[slot_100] = 100;
        values[slot_100] = 2000;
        occupied[slot_100] = true;
        size = size + 1;
    }
    
    // Check both values
    let check_50 = find_slot(keys, occupied, 50);
    let check_100 = find_slot(keys, occupied, 100);
    
    if check_50 >= 0 && check_100 >= 0 {
        if values[check_50] == 1000 && values[check_100] == 2000 {
            print("âœ“ Collision handling works");
        } else {
            print("âœ— Collision handling failed");
            print_int(values[check_50]);
            print_int(values[check_100]);
        }
    } else {
        print("âœ— Failed to handle collisions");
    }
    
    print("\n=== Integer Map Tests Complete ===");
    print("Basic map functionality demonstrated!");
    print("Total entries:");
    print_int(size);
}

// Demonstrate practical usage
fn demo_line_tracking() {
    print("\n=== Line Number Tracking Demo ===");
    
    // Track error codes by line number
    let mut lines: [i64; 50] = [0; 50];
    let mut errors: [i64; 50] = [0; 50];
    let mut has_error: [bool; 50] = [false; 50];
    let mut error_count = 0;
    
    // Add some errors
    // Line 15: Error 404
    let slot1 = find_slot(lines, has_error, 15);
    if slot1 >= 0 {
        if has_error[slot1] == false {
            error_count = error_count + 1;
        }
        lines[slot1] = 15;
        errors[slot1] = 404;
        has_error[slot1] = true;
    }
    
    // Line 27: Error 500
    let slot2 = find_slot(lines, has_error, 27);
    if slot2 >= 0 {
        if has_error[slot2] == false {
            error_count = error_count + 1;
        }
        lines[slot2] = 27;
        errors[slot2] = 500;
        has_error[slot2] = true;
    }
    
    // Line 42: Error 403
    let slot3 = find_slot(lines, has_error, 42);
    if slot3 >= 0 {
        if has_error[slot3] == false {
            error_count = error_count + 1;
        }
        lines[slot3] = 42;
        errors[slot3] = 403;
        has_error[slot3] = true;
    }
    
    // Line 88: Error 422
    let slot4 = find_slot(lines, has_error, 88);
    if slot4 >= 0 {
        if has_error[slot4] == false {
            error_count = error_count + 1;
        }
        lines[slot4] = 88;
        errors[slot4] = 422;
        has_error[slot4] = true;
    }
    
    print("Tracking errors on:");
    print_int(error_count);
    print("lines");
    
    // Look up specific errors
    let check_line = find_slot(lines, has_error, 42);
    if check_line >= 0 && has_error[check_line] {
        print("Line 42 has error code:");
        print_int(errors[check_line]);
    }
    
    print("\nThis shows we can build compiler diagnostics! ðŸŽ‰");
}

fn main() {
    test_int_map();
    demo_line_tracking();
}