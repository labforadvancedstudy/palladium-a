// Simplified HashMap for integer keys and values
// This avoids the String array issue and still demonstrates the concept

struct IntHashMap {
    keys: [i64; 50],      // Integer keys
    values: [i64; 50],    // Integer values  
    occupied: [bool; 50], // Which slots are occupied
    size: i64,            // Number of entries
}

// Simple hash function for integers
fn hash_int(key: i64) -> i64 {
    // Simple modulo hash
    let hash = key % 50;
    if hash < 0 {
        return 0 - hash;  // Work around unary minus limitation
    }
    return hash;
}

// Create a new empty IntHashMap
fn int_hashmap_new() -> IntHashMap {
    // Initialize arrays
    let empty_keys = [0; 50];
    let empty_values = [0; 50];
    let empty_occupied = [false; 50];
    
    return IntHashMap {
        keys: empty_keys,
        values: empty_values,
        occupied: empty_occupied,
        size: 0
    };
}

// Insert a key-value pair
fn int_hashmap_insert(map: IntHashMap, key: i64, value: i64) -> IntHashMap {
    let hash_idx = hash_int(key);
    let mut idx = hash_idx;
    let mut new_map = map;
    
    // Linear probing to find empty slot or existing key
    let mut found = false;
    let mut attempts = 0;
    
    while attempts < 50 && found == false {
        if new_map.occupied[idx] == false || new_map.keys[idx] == key {
            found = true;
        } else {
            idx = (idx + 1) % 50;
            attempts = attempts + 1;
        }
    }
    
    if found {
        // Update or insert
        if new_map.occupied[idx] == false {
            new_map.size = new_map.size + 1;
        }
        
        new_map.keys[idx] = key;
        new_map.values[idx] = value;
        new_map.occupied[idx] = true;
    }
    
    return new_map;
}

// Get a value by key
fn int_hashmap_get(map: IntHashMap, key: i64) -> i64 {
    let hash_idx = hash_int(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 50 {
        if map.occupied[idx] && map.keys[idx] == key {
            return map.values[idx];
        }
        
        if map.occupied[idx] == false {
            // Key not found
            return -9999;  // Magic value for "not found"
        }
        
        idx = (idx + 1) % 50;
        attempts = attempts + 1;
    }
    
    return -9999;  // Not found
}

// Check if key exists
fn int_hashmap_contains(map: IntHashMap, key: i64) -> bool {
    let hash_idx = hash_int(key);
    let mut idx = hash_idx;
    let mut attempts = 0;
    
    while attempts < 50 {
        if map.occupied[idx] && map.keys[idx] == key {
            return true;
        }
        
        if map.occupied[idx] == false {
            return false;
        }
        
        idx = (idx + 1) % 50;
        attempts = attempts + 1;
    }
    
    return false;
}

// Remove a key
fn int_hashmap_remove(map: IntHashMap, key: i64) -> IntHashMap {
    let hash_idx = hash_int(key);
    let mut idx = hash_idx;
    let mut new_map = map;
    let mut attempts = 0;
    
    while attempts < 50 {
        if new_map.occupied[idx] && new_map.keys[idx] == key {
            // Mark as not occupied
            new_map.occupied[idx] = false;
            new_map.size = new_map.size - 1;
            
            // TODO: Should rehash entries after this position
            // For simplicity, we're leaving tombstones
            
            return new_map;
        }
        
        if new_map.occupied[idx] == false {
            // Key not found
            return new_map;
        }
        
        idx = (idx + 1) % 50;
        attempts = attempts + 1;
    }
    
    return new_map;
}

// Get the size of the IntHashMap
fn int_hashmap_size(map: IntHashMap) -> i64 {
    return map.size;
}

// Test the IntHashMap implementation
fn test_int_hashmap() {
    print("=== IntHashMap Implementation Tests ===\n");
    
    // Test 1: Basic insertion and retrieval
    print("Test 1: Basic operations");
    let mut map = int_hashmap_new();
    
    map = int_hashmap_insert(map, 42, 100);
    map = int_hashmap_insert(map, 17, 200);
    map = int_hashmap_insert(map, 99, 300);
    
    let val1 = int_hashmap_get(map, 42);
    let val2 = int_hashmap_get(map, 17);
    let val3 = int_hashmap_get(map, 99);
    
    if val1 == 100 && val2 == 200 && val3 == 300 {
        print("âœ“ Basic insertion and retrieval works");
    } else {
        print("âœ— Basic operations failed");
        print_int(val1);
        print_int(val2);
        print_int(val3);
    }
    
    // Test 2: Size tracking
    if int_hashmap_size(map) == 3 {
        print("âœ“ Size tracking works");
    } else {
        print("âœ— Size tracking failed");
        print_int(int_hashmap_size(map));
    }
    
    // Test 3: Contains check
    if int_hashmap_contains(map, 42) && int_hashmap_contains(map, 17) {
        if int_hashmap_contains(map, 999) == false {
            print("âœ“ Contains check works");
        } else {
            print("âœ— Contains returned true for non-existent key");
        }
    } else {
        print("âœ— Contains check failed");
    }
    
    // Test 4: Update existing key
    map = int_hashmap_insert(map, 42, 999);
    let updated = int_hashmap_get(map, 42);
    
    if updated == 999 && int_hashmap_size(map) == 3 {
        print("âœ“ Updating existing key works");
    } else {
        print("âœ— Update failed");
        print_int(updated);
        print_int(int_hashmap_size(map));
    }
    
    // Test 5: Removal
    map = int_hashmap_remove(map, 17);
    
    if int_hashmap_contains(map, 17) == false && int_hashmap_size(map) == 2 {
        print("âœ“ Removal works");
    } else {
        print("âœ— Removal failed");
    }
    
    // Test 6: Hash collision handling
    print("\nTest 2: Collision handling");
    
    // Force some collisions (50 and 100 both hash to 0)
    map = int_hashmap_insert(map, 50, 1000);
    map = int_hashmap_insert(map, 100, 2000);
    map = int_hashmap_insert(map, 150, 3000);
    
    let collision_test = 
        int_hashmap_get(map, 50) == 1000 &&
        int_hashmap_get(map, 100) == 2000 &&
        int_hashmap_get(map, 150) == 3000;
    
    if collision_test {
        print("âœ“ Collision handling works");
    } else {
        print("âœ— Collision handling failed");
        print_int(int_hashmap_get(map, 50));
        print_int(int_hashmap_get(map, 100));
        print_int(int_hashmap_get(map, 150));
    }
    
    print("\n=== IntHashMap Tests Complete ===");
    print("Integer HashMap is functional!");
}

// Demonstrate practical usage with enum values
fn demo_token_table() {
    print("\n=== Token Type Table Demo ===");
    
    let mut tokens = int_hashmap_new();
    
    // Token type IDs
    let TOKEN_IDENT = 1;
    let TOKEN_NUMBER = 2;
    let TOKEN_STRING = 3;
    let TOKEN_IF = 10;
    let TOKEN_ELSE = 11;
    let TOKEN_WHILE = 12;
    let TOKEN_FOR = 13;
    let TOKEN_FN = 14;
    
    // Map line numbers to token types
    tokens = int_hashmap_insert(tokens, 1, TOKEN_FN);
    tokens = int_hashmap_insert(tokens, 2, TOKEN_IDENT);
    tokens = int_hashmap_insert(tokens, 3, TOKEN_IF);
    tokens = int_hashmap_insert(tokens, 4, TOKEN_NUMBER);
    tokens = int_hashmap_insert(tokens, 5, TOKEN_ELSE);
    
    print("Token table created with:");
    print_int(int_hashmap_size(tokens));
    print("entries");
    
    // Lookup tokens
    let line3_token = int_hashmap_get(tokens, 3);
    if line3_token == TOKEN_IF {
        print("âœ“ Line 3 has IF token");
    }
    
    let line1_token = int_hashmap_get(tokens, 1);
    if line1_token == TOKEN_FN {
        print("âœ“ Line 1 has FN token");
    }
    
    print("\nThis demonstrates we can build compiler data structures! ðŸŽ‰");
}

fn main() {
    test_int_hashmap();
    demo_token_table();
}