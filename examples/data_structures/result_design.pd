// Result type design for Palladium error handling
// This demonstrates what we want to implement

// The Result type is fundamental for error handling
enum Result {
    Ok(i64),    // Success case with value
    Err(String), // Error case with message
}

// Helper functions for Result
fn is_ok(r: Result) -> bool {
    match r {
        Result::Ok(_) => true,
        Result::Err(_) => false,
    }
}

fn unwrap(r: Result) -> i64 {
    match r {
        Result::Ok(value) => value,
        Result::Err(msg) => {
            print("Error:");
            print(msg);
            // In real implementation, would panic
            return -1;
        }
    }
}

// Example usage
fn divide(a: i64, b: i64) -> Result {
    if b == 0 {
        return Result::Err("Division by zero");
    }
    return Result::Ok(a / b);
}

fn main() {
    let result1 = divide(10, 2);
    if is_ok(result1) {
        print("Division succeeded:");
        print_int(unwrap(result1));
    }
    
    let result2 = divide(10, 0);
    if is_ok(result2) == false {
        print("Division failed as expected");
    }
}