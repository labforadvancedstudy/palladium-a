// Result type for error handling in Palladium
// Essential for robust compiler implementation

// Generic Result type with Ok and Err variants
enum Result {
    Ok(String),    // For now, we'll use String for both T and E
    Err(String),   // Until we have full generics
}

// Helper functions for Result type
fn result_is_ok(r: Result) -> bool {
    match r {
        Result::Ok(_) => true,
        Result::Err(_) => false,
    }
}

fn result_is_err(r: Result) -> bool {
    match r {
        Result::Ok(_) => false,
        Result::Err(_) => true,
    }
}

fn result_unwrap(r: Result) -> String {
    match r {
        Result::Ok(value) => value,
        Result::Err(msg) => {
            print("Error: unwrap called on Err:");
            print(msg);
            // In real implementation, would panic/exit
            return "";
        }
    }
}

fn result_unwrap_or(r: Result, default: String) -> String {
    match r {
        Result::Ok(value) => value,
        Result::Err(_) => default,
    }
}

fn result_map_err(r: Result, prefix: String) -> Result {
    match r {
        Result::Ok(value) => Result::Ok(value),
        Result::Err(msg) => Result::Err(string_concat(prefix, msg)),
    }
}

// Example: Parse integer with error handling
fn parse_int_safe(s: String) -> Result {
    let len = string_len(s);
    if len == 0 {
        return Result::Err("Empty string");
    }
    
    let mut i = 0;
    let mut is_negative = false;
    
    // Check for negative sign
    let first_char = string_char_at(s, 0);
    if first_char == 45 { // '-'
        is_negative = true;
        i = 1;
        if len == 1 {
            return Result::Err("Invalid number: just a minus sign");
        }
    }
    
    // Check all remaining chars are digits
    while i < len {
        let c = string_char_at(s, i);
        if char_is_digit(c) == false {
            return Result::Err(string_concat("Invalid character at position ", string_from_char(c)));
        }
        i = i + 1;
    }
    
    // If we got here, it's a valid number
    return Result::Ok(s);
}

// Example: Safe file reading
fn read_file_safe(path: String) -> Result {
    if file_exists(path) == false {
        return Result::Err(string_concat("File not found: ", path));
    }
    
    let handle = file_open(path);
    if handle == -1 {
        return Result::Err(string_concat("Failed to open file: ", path));
    }
    
    let content = file_read_all(handle);
    file_close(handle);
    
    if string_len(content) == 0 {
        return Result::Err("File is empty");
    }
    
    return Result::Ok(content);
}

// Example: Chain operations with error handling
fn process_config_file(path: String) -> Result {
    // Read file
    let content_result = read_file_safe(path);
    if result_is_err(content_result) {
        return result_map_err(content_result, "Config error: ");
    }
    
    let content = result_unwrap(content_result);
    
    // Validate content (simplified)
    if string_len(content) > 1000 {
        return Result::Err("Config file too large");
    }
    
    return Result::Ok(content);
}

fn test_result_type() {
    print("=== Testing Result Type ===");
    
    // Test Ok case
    let ok_result = Result::Ok("Success!");
    if result_is_ok(ok_result) {
        print("is_ok test: PASS");
    }
    
    let value = result_unwrap(ok_result);
    print(string_concat("Unwrapped value: ", value));
    
    // Test Err case
    let err_result = Result::Err("Something went wrong");
    if result_is_err(err_result) {
        print("is_err test: PASS");
    }
    
    let default_value = result_unwrap_or(err_result, "default");
    print(string_concat("Unwrap_or value: ", default_value));
    
    // Test parse_int_safe
    print("\nTesting parse_int_safe:");
    let num_result = parse_int_safe("123");
    if result_is_ok(num_result) {
        print("Valid number: PASS");
    }
    
    let invalid_result = parse_int_safe("12a3");
    if result_is_err(invalid_result) {
        print("Invalid number detected: PASS");
    }
    
    // Test file operations
    print("\nTesting file operations:");
    let file_result = read_file_safe("nonexistent.txt");
    if result_is_err(file_result) {
        print("Nonexistent file error: PASS");
    }
    
    // Test error mapping
    let mapped = result_map_err(file_result, "IO Error: ");
    match mapped {
        Result::Err(msg) => {
            print("Error mapping test:");
            print(msg);
        }
        Result::Ok(_) => print("Error mapping failed"),
    }
}

fn main() {
    test_result_type();
    
    // Practical example
    print("\n=== Practical Example ===");
    let config_result = process_config_file("config.txt");
    match config_result {
        Result::Ok(config) => {
            print("Config loaded successfully");
        }
        Result::Err(error) => {
            print("Failed to load config:");
            print(error);
        }
    }
}