// Demonstration of compiler-relevant data structures in Palladium
// Shows that we have enough features to start building a compiler!

// Token representation
struct Token {
    kind: i64,      // Token type (using integers for now)
    line: i64,      // Line number
    column: i64,    // Column number
    length: i64,    // Token length
}

// AST node for expressions
struct ASTNode {
    node_type: i64,     // Expression type
    value: i64,         // For literals
    left_child: i64,    // Index of left child (-1 if none)
    right_child: i64,   // Index of right child (-1 if none)
}

// Simple symbol entry
struct Symbol {
    hash: i64,      // Hash of the name
    kind: i64,      // Variable, function, etc.
    type_id: i64,   // Type information
    scope: i64,     // Scope level
}

// Compiler state
struct CompilerState {
    tokens: [Token; 100],           // Token stream
    token_count: i64,               // Number of tokens
    ast_nodes: [ASTNode; 100],      // AST node pool
    ast_count: i64,                 // Number of AST nodes
    symbols: [Symbol; 50],          // Symbol table
    symbol_count: i64,              // Number of symbols
    current_token: i64,             // Parser position
    current_scope: i64,             // Current scope level
}

// Token types
fn token_type_number() -> i64 { return 1; }
fn token_type_plus() -> i64 { return 2; }
fn token_type_minus() -> i64 { return 3; }
fn token_type_star() -> i64 { return 4; }
fn token_type_eof() -> i64 { return 99; }

// AST node types
fn ast_type_literal() -> i64 { return 1; }
fn ast_type_binary_op() -> i64 { return 2; }

// Create a new compiler state
fn compiler_new() -> CompilerState {
    let empty_token = Token { kind: 0, line: 0, column: 0, length: 0 };
    let empty_ast = ASTNode { node_type: 0, value: 0, left_child: -1, right_child: -1 };
    let empty_symbol = Symbol { hash: 0, kind: 0, type_id: 0, scope: 0 };
    
    return CompilerState {
        tokens: [empty_token; 100],
        token_count: 0,
        ast_nodes: [empty_ast; 100],
        ast_count: 0,
        symbols: [empty_symbol; 50],
        symbol_count: 0,
        current_token: 0,
        current_scope: 0
    };
}

// Add a token to the compiler state
fn add_token(state: CompilerState, kind: i64, line: i64, col: i64) -> CompilerState {
    let mut new_state: CompilerState = state;
    
    if new_state.token_count < 100 {
        new_state.tokens[new_state.token_count] = Token {
            kind: kind,
            line: line,
            column: col,
            length: 1
        };
        new_state.token_count = new_state.token_count + 1;
    }
    
    return new_state;
}

// Add an AST node
fn add_ast_node(state: CompilerState, node_type: i64, value: i64, left: i64, right: i64) -> CompilerState {
    let mut new_state: CompilerState = state;
    
    if new_state.ast_count < 100 {
        new_state.ast_nodes[new_state.ast_count] = ASTNode {
            node_type: node_type,
            value: value,
            left_child: left,
            right_child: right
        };
        new_state.ast_count = new_state.ast_count + 1;
    }
    
    return new_state;
}

// Demo: Tokenize a simple expression "2 + 3 * 4"
fn demo_tokenizer() {
    print("=== Tokenizer Demo ===");
    
    let mut compiler = compiler_new();
    
    // Add tokens for "2 + 3 * 4"
    compiler = add_token(compiler, token_type_number(), 1, 1);  // 2
    compiler = add_token(compiler, token_type_plus(), 1, 3);    // +
    compiler = add_token(compiler, token_type_number(), 1, 5);  // 3
    compiler = add_token(compiler, token_type_star(), 1, 7);    // *
    compiler = add_token(compiler, token_type_number(), 1, 9);  // 4
    compiler = add_token(compiler, token_type_eof(), 1, 10);    // EOF
    
    print("Tokenized expression: 2 + 3 * 4");
    print("Token count:");
    print_int(compiler.token_count);
    
    // Display tokens
    for i in 0..compiler.token_count {
        print("Token");
        print_int(i);
        print("- Type:");
        print_int(compiler.tokens[i].kind);
        print(", Line:");
        print_int(compiler.tokens[i].line);
        print(", Col:");
        print_int(compiler.tokens[i].column);
    }
}

// Demo: Build AST for "2 + 3 * 4" (respecting precedence)
fn demo_parser() {
    print("\n=== Parser Demo ===");
    
    let mut compiler = compiler_new();
    
    // Build AST nodes
    // Node 0: Literal 2
    compiler = add_ast_node(compiler, ast_type_literal(), 2, -1, -1);
    // Node 1: Literal 3
    compiler = add_ast_node(compiler, ast_type_literal(), 3, -1, -1);
    // Node 2: Literal 4
    compiler = add_ast_node(compiler, ast_type_literal(), 4, -1, -1);
    // Node 3: 3 * 4
    compiler = add_ast_node(compiler, ast_type_binary_op(), token_type_star(), 1, 2);
    // Node 4: 2 + (3 * 4)
    compiler = add_ast_node(compiler, ast_type_binary_op(), token_type_plus(), 0, 3);
    
    print("Built AST for: 2 + 3 * 4");
    print("AST node count:");
    print_int(compiler.ast_count);
    
    // Display AST structure
    print("\nAST Structure:");
    let root = 4;
    print("Root node (index 4): + operator");
    print("  Left child (index 0): Literal 2");
    print("  Right child (index 3): * operator");
    print("    Left child (index 1): Literal 3");
    print("    Right child (index 2): Literal 4");
}

// Demo: Symbol table
fn demo_symbol_table() {
    print("\n=== Symbol Table Demo ===");
    
    let mut compiler = compiler_new();
    
    // Add some symbols
    let sym1 = Symbol { hash: 12345, kind: 1, type_id: 1, scope: 0 };  // Variable x
    let sym2 = Symbol { hash: 23456, kind: 1, type_id: 1, scope: 0 };  // Variable y
    let sym3 = Symbol { hash: 34567, kind: 2, type_id: 2, scope: 0 };  // Function main
    
    compiler.symbols[0] = sym1;
    compiler.symbols[1] = sym2;
    compiler.symbols[2] = sym3;
    compiler.symbol_count = 3;
    
    print("Added 3 symbols to table");
    
    // Lookup simulation
    let target_hash = 23456;
    let mut found = false;
    let mut found_idx = -1;
    
    for i in 0..compiler.symbol_count {
        if compiler.symbols[i].hash == target_hash {
            found = true;
            found_idx = i;
        }
    }
    
    if found && found_idx >= 0 {
        print("Found symbol with hash 23456:");
        print("  Kind:");
        print_int(compiler.symbols[found_idx].kind);
        print("  Type:");
        print_int(compiler.symbols[found_idx].type_id);
    }
}

fn main() {
    print("=== Compiler Data Structures Demo ===\n");
    print("This demonstrates that Palladium has the features needed");
    print("to build a compiler!\n");
    
    demo_tokenizer();
    demo_parser();
    demo_symbol_table();
    
    print("\n=== Demo Complete ===");
    print("We can now start building a Palladium compiler in Palladium! ðŸš€");
}