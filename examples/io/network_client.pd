// Network client example
// "Connecting to the world with Palladium"

use std::net::{TcpStream, SocketAddr, Ipv4Addr, SocketAddrV4};
use std::io::{println, eprintln};
use std::result::{Result, ok, err};
use std::time::Duration;
use std::string::String;

fn main() {
    // Create a server address
    let addr = SocketAddr::V4(SocketAddrV4::new(
        Ipv4Addr::new(127, 0, 0, 1),
        8080
    ));
    
    // Connect to server
    match TcpStream::connect(&addr) {
        Result::Ok(mut stream) => {
            println(&"Connected to server!");
            
            // Send a message
            let message = "Hello from Palladium client!\n";
            match stream.write(&message.as_bytes()) {
                Result::Ok(bytes) => {
                    println(&string_concat("Sent ", string_concat(int_to_string(bytes), " bytes")));
                }
                Result::Err(e) => {
                    eprintln(&string_concat("Error writing: ", e.to_string()));
                    return;
                }
            }
            
            // Read response
            let mut buffer = [0u8; 1024];
            match stream.read(&mut buffer) {
                Result::Ok(bytes) => {
                    let response = String::from_utf8(&buffer[0..bytes]);
                    match response {
                        Result::Ok(s) => println(&string_concat("Received: ", s)),
                        Result::Err(_) => println(&"Received non-UTF8 data"),
                    }
                }
                Result::Err(e) => {
                    eprintln(&string_concat("Error reading: ", e.to_string()));
                }
            }
            
            // Get peer address
            match stream.peer_addr() {
                Result::Ok(peer) => {
                    println(&string_concat("Connected to: ", addr_to_string(&peer)));
                }
                Result::Err(_) => {}
            }
            
            // Shutdown connection
            match stream.shutdown(Shutdown::Both) {
                Result::Ok(_) => println(&"Connection closed"),
                Result::Err(_) => {}
            }
        }
        Result::Err(e) => {
            eprintln(&string_concat("Failed to connect: ", e.to_string()));
        }
    }
}

// HTTP GET request example
fn http_get(host: &String, path: &String, port: u16) -> Result<String, IoError> {
    // Resolve host
    let addrs = lookup_host(host)?;
    if addrs.is_empty() {
        return err(IoError::Other(String::from("No addresses found")));
    }
    
    // Use first address
    let addr = match addrs[0] {
        IpAddr::V4(v4) => SocketAddr::V4(SocketAddrV4::new(v4, port)),
        IpAddr::V6(v6) => SocketAddr::V6(SocketAddrV6::new(v6, port, 0, 0)),
    };
    
    // Connect with timeout
    let timeout = Duration::from_secs(10);
    let mut stream = TcpStream::connect_timeout(&addr, timeout)?;
    
    // Build HTTP request
    let request = string_concat(
        string_concat("GET ", string_concat(*path, " HTTP/1.1\r\n")),
        string_concat(
            string_concat("Host: ", string_concat(*host, "\r\n")),
            "Connection: close\r\n\r\n"
        )
    );
    
    // Send request
    stream.write(&request.as_bytes())?;
    
    // Read response
    let mut response = String::new();
    let mut buffer = [0u8; 4096];
    
    loop {
        match stream.read(&mut buffer) {
            Result::Ok(0) => break, // EOF
            Result::Ok(n) => {
                match String::from_utf8(&buffer[0..n]) {
                    Result::Ok(chunk) => response = string_concat(response, chunk),
                    Result::Err(_) => return err(IoError::InvalidInput),
                }
            }
            Result::Err(e) => {
                if e == IoError::UnexpectedEof {
                    break;
                } else {
                    return err(e);
                }
            }
        }
    }
    
    ok(response)
}

// Simple echo client
fn echo_client(server_addr: &SocketAddr) -> Result<(), IoError> {
    let mut stream = TcpStream::connect(server_addr)?;
    
    // Set TCP_NODELAY for interactive use
    stream.set_nodelay(true)?;
    
    println(&"Connected to echo server. Type messages (empty line to quit):");
    
    loop {
        // Read from stdin (would need stdin support)
        let input = "Test message\n"; // Placeholder
        
        if input.is_empty() {
            break;
        }
        
        // Send to server
        stream.write(&input.as_bytes())?;
        
        // Read echo
        let mut buffer = [0u8; 1024];
        match stream.read(&mut buffer) {
            Result::Ok(n) => {
                let echo = String::from_utf8(&buffer[0..n])?;
                print(&string_concat("Echo: ", echo));
            }
            Result::Err(_) => break,
        }
    }
    
    ok(())
}

// Helper to convert address to string
fn addr_to_string(addr: &SocketAddr) -> String {
    match addr {
        SocketAddr::V4(v4) => {
            let ip = v4.ip();
            let port = v4.port();
            string_concat(ip.to_string(), string_concat(":", int_to_string(port)))
        }
        SocketAddr::V6(v6) => {
            let ip = v6.ip();
            let port = v6.port();
            string_concat("[", string_concat(ip.to_string(), string_concat("]:", int_to_string(port))))
        }
    }
}