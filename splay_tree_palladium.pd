// Palladium implementation of Splay Tree
// Demonstrates implicit lifetimes, cleaner syntax, and totality annotations

#![total(strict)]  // Enable totality checking

use std::cmp::Ordering;

struct SplayTree<T: Ord> {
    root: Option<Node<T>>,  // No explicit Box needed
}

struct Node<T> {
    value: T,
    left: Option<Node<T>>,
    right: Option<Node<T>>,
}

impl<T: Ord> Node<T> {
    fn new(value: T) -> Self {
        Node { value, left: None, right: None }
    }
}

impl<T: Ord> SplayTree<T> {
    fn new() -> Self {
        SplayTree { root: None }
    }

    #[decreases(self.depth())]  // Totality metric for verification
    fn insert(&mut self, value: T) {
        if self.root.is_none() {
            self.root = Some(Node::new(value));
            return;
        }
        
        self.splay(|v| value.cmp(v));
        
        let mut root = self.root.take()?;  // Cleaner unwrap with ?
        match value.cmp(&root.value) {
            Less => {
                let new_root = Node {
                    value,
                    left: root.left.take(),
                    right: Some(root),
                };
                self.root = Some(new_root);
            }
            Greater => {
                let new_root = Node {
                    value,
                    right: root.right.take(),
                    left: Some(root),
                };
                self.root = Some(new_root);
            }
            Equal => self.root = Some(root),
        }
    }

    fn find(&mut self, value: ref T) -> bool {  // ref keyword instead of &
        self.root.is_some() && {
            self.splay(|v| value.cmp(v));
            self.root.as_ref()?.value == value
        }
    }

    fn delete(&mut self, value: ref T) -> bool {
        if self.root.is_none() {
            return false;
        }
        
        self.splay(|v| value.cmp(v));
        
        let root = self.root.as_ref()?;
        if root.value != value {
            return false;
        }
        
        let root = self.root.take()?;
        self.root = match (root.left, root.right) {
            (None, None) => None,
            (Some(left), None) => Some(left),
            (None, Some(right)) => Some(right),
            (Some(left), Some(right)) => {
                self.root = Some(left);
                self.splay_max();
                let mut new_root = self.root.take()?;
                new_root.right = Some(right);
                Some(new_root)
            }
        };
        
        true
    }

    #[decreases(self.depth())]  // Totality proof obligation
    fn splay<F>(&mut self, mut cmp: F)
    where F: FnMut(ref T) -> Ordering  // ref in closure signature
    {
        let (mut left_tree, mut right_tree) = (None, None);
        let mut left_rightmost = ref mut left_tree;
        let mut right_leftmost = ref mut right_tree;
        
        let mut current = self.root.take();
        
        while let Some(mut node) = current {
            match cmp(ref node.value) {
                Less => {
                    if let Some(mut left) = node.left.take() {
                        match cmp(ref left.value) {
                            Less => {
                                // Zig-zig rotation
                                node.left = left.right.take();
                                left.right = Some(node);
                                current = left.left.take();
                                *right_leftmost = Some(left);
                                right_leftmost = ref mut right_leftmost.as_mut()?.left;
                            }
                            _ => {
                                // Zig rotation
                                current = left.left.take();
                                node.left = left.right.take();
                                left.right = Some(node);
                                *right_leftmost = Some(left);
                                right_leftmost = ref mut right_leftmost.as_mut()?.left;
                            }
                        }
                    } else {
                        current = None;
                        *right_leftmost = Some(node);
                    }
                }
                Greater => {
                    if let Some(mut right) = node.right.take() {
                        match cmp(ref right.value) {
                            Greater => {
                                // Zag-zag rotation
                                node.right = right.left.take();
                                right.left = Some(node);
                                current = right.right.take();
                                *left_rightmost = Some(right);
                                left_rightmost = ref mut left_rightmost.as_mut()?.right;
                            }
                            _ => {
                                // Zag rotation
                                current = right.right.take();
                                node.right = right.left.take();
                                right.left = Some(node);
                                *left_rightmost = Some(right);
                                left_rightmost = ref mut left_rightmost.as_mut()?.right;
                            }
                        }
                    } else {
                        current = None;
                        *left_rightmost = Some(node);
                    }
                }
                Equal => {
                    node.left = left_tree;
                    node.right = right_tree;
                    self.root = Some(node);
                    return;
                }
            }
        }
        
        *left_rightmost = right_tree;
        self.root = left_tree;
    }

    fn splay_max(&mut self) {
        self.splay(|_| Less);
    }
    
    // Helper for totality verification
    #[pure]  // Side-effect free function for proofs
    fn depth(&self) -> nat {
        match ref self.root {
            None => 0,
            Some(node) => 1 + max(node.left_depth(), node.right_depth()),
        }
    }
}

// Effect-polymorphic test module
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_insert_and_find() -> test::Result {
        let mut tree = SplayTree::new();
        tree.insert(10);
        tree.insert(5);
        tree.insert(15);
        
        assert!(tree.find(ref 10));
        assert!(tree.find(ref 5));
        assert!(tree.find(ref 15));
        assert!(!tree.find(ref 20));
        Ok(())
    }

    #[test]
    fn test_delete() -> test::Result {
        let mut tree = SplayTree::new();
        tree.insert(10);
        tree.insert(5);
        tree.insert(15);
        
        assert!(tree.delete(ref 5));
        assert!(!tree.find(ref 5));
        assert!(tree.find(ref 10));
        assert!(tree.find(ref 15));
        Ok(())
    }
    
    // Totality proof test - compiler verifies termination
    #[test]
    #[verify_total]
    fn test_termination() -> test::Result {
        let mut tree = SplayTree::new();
        for i in 0..100 {
            tree.insert(i);  // Compiler proves this terminates
        }
        Ok(())
    }
}