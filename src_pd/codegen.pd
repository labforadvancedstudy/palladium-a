// Palladium Self-Hosting Compiler - Code Generation Module
// C code generation backend for the Palladium language

// ============ Code Generator State ============

struct CodeGen {
    output: String,
    indent_level: i64,
    temp_counter: i64,
    label_counter: i64,
}

// ============ Code Generator Creation ============

fn create_codegen() -> CodeGen {
    return CodeGen {
        output: "",
        indent_level: 0,
        temp_counter: 0,
        label_counter: 0,
    };
}

// ============ Output Functions ============

fn emit(gen: &mut CodeGen, code: String) {
    gen.output = string_concat(gen.output, code);
}

fn emit_line(gen: &mut CodeGen, code: String) {
    // Add indentation
    let mut i = 0;
    while i < gen.indent_level {
        emit(gen, "    ");
        i = i + 1;
    }
    emit(gen, code);
    emit(gen, "\n");
}

fn emit_newline(gen: &mut CodeGen) {
    emit(gen, "\n");
}

fn indent(gen: &mut CodeGen) {
    gen.indent_level = gen.indent_level + 1;
}

fn dedent(gen: &mut CodeGen) {
    if gen.indent_level > 0 {
        gen.indent_level = gen.indent_level - 1;
    }
}

fn next_temp(gen: &mut CodeGen) -> String {
    let temp = string_concat("_t", int_to_string(gen.temp_counter));
    gen.temp_counter = gen.temp_counter + 1;
    return temp;
}

fn next_label(gen: &mut CodeGen) -> String {
    let label = string_concat("_L", int_to_string(gen.label_counter));
    gen.label_counter = gen.label_counter + 1;
    return label;
}

// ============ Code Generation ============

fn generate_program(gen: &mut CodeGen, program: &Program) {
    // Emit includes
    emit_line(gen, "#include <stdio.h>");
    emit_line(gen, "#include <stdlib.h>");
    emit_line(gen, "#include <string.h>");
    emit_line(gen, "#include <stdbool.h>");
    emit_newline(gen);
    
    // Emit runtime functions
    emit_runtime_functions(gen);
    
    // Forward declare functions
    let mut i = 0;
    while i < program.item_count {
        if program.items[i].kind == ITEM_FUNCTION {
            generate_function_declaration(gen, &program.items[i]);
        }
        i = i + 1;
    }
    emit_newline(gen);
    
    // Generate items
    i = 0;
    while i < program.item_count {
        generate_item(gen, &program.items[i]);
        i = i + 1;
    }
}

fn emit_runtime_functions(gen: &mut CodeGen) {
    // String type
    emit_line(gen, "typedef struct {");
    indent(gen);
    emit_line(gen, "char* data;");
    emit_line(gen, "size_t len;");
    emit_line(gen, "size_t capacity;");
    dedent(gen);
    emit_line(gen, "} __pd_string;");
    emit_newline(gen);
    
    // Runtime function prototypes
    emit_line(gen, "void __pd_print(const char* s);");
    emit_line(gen, "void __pd_print_int(long long n);");
    emit_line(gen, "__pd_string __pd_string_new(const char* s);");
    emit_line(gen, "__pd_string __pd_string_concat(__pd_string a, __pd_string b);");
    emit_line(gen, "long long __pd_string_len(__pd_string s);");
    emit_line(gen, "long long __pd_string_char_at(__pd_string s, long long idx);");
    emit_line(gen, "__pd_string __pd_string_from_char(long long ch);");
    emit_line(gen, "__pd_string __pd_int_to_string(long long n);");
    emit_newline(gen);
    
    // Runtime function implementations
    emit_line(gen, "// Runtime function implementations");
    emit_line(gen, "void __pd_print(const char* s) {");
    indent(gen);
    emit_line(gen, "printf(\"%s\\n\", s);");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
    
    emit_line(gen, "void __pd_print_int(long long n) {");
    indent(gen);
    emit_line(gen, "printf(\"%lld\\n\", n);");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
    
    emit_line(gen, "__pd_string __pd_string_new(const char* s) {");
    indent(gen);
    emit_line(gen, "__pd_string str;");
    emit_line(gen, "size_t len = strlen(s);");
    emit_line(gen, "str.data = malloc(len + 1);");
    emit_line(gen, "strcpy(str.data, s);");
    emit_line(gen, "str.len = len;");
    emit_line(gen, "str.capacity = len + 1;");
    emit_line(gen, "return str;");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
    
    emit_line(gen, "__pd_string __pd_string_concat(__pd_string a, __pd_string b) {");
    indent(gen);
    emit_line(gen, "__pd_string result;");
    emit_line(gen, "result.len = a.len + b.len;");
    emit_line(gen, "result.capacity = result.len + 1;");
    emit_line(gen, "result.data = malloc(result.capacity);");
    emit_line(gen, "strcpy(result.data, a.data);");
    emit_line(gen, "strcat(result.data, b.data);");
    emit_line(gen, "return result;");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
    
    emit_line(gen, "long long __pd_string_len(__pd_string s) {");
    indent(gen);
    emit_line(gen, "return s.len;");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
    
    emit_line(gen, "long long __pd_string_char_at(__pd_string s, long long idx) {");
    indent(gen);
    emit_line(gen, "if (idx >= 0 && idx < s.len) {");
    indent(gen);
    emit_line(gen, "return s.data[idx];");
    dedent(gen);
    emit_line(gen, "}");
    emit_line(gen, "return 0;");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
    
    emit_line(gen, "__pd_string __pd_string_from_char(long long ch) {");
    indent(gen);
    emit_line(gen, "char buf[2] = {ch, 0};");
    emit_line(gen, "return __pd_string_new(buf);");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
    
    emit_line(gen, "__pd_string __pd_int_to_string(long long n) {");
    indent(gen);
    emit_line(gen, "char buf[32];");
    emit_line(gen, "snprintf(buf, sizeof(buf), \"%lld\", n);");
    emit_line(gen, "return __pd_string_new(buf);");
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
}

// ============ Item Generation ============

fn generate_item(gen: &mut CodeGen, item: &Item) {
    if item.kind == ITEM_FUNCTION {
        generate_function(gen, item);
    } else if item.kind == ITEM_STRUCT {
        generate_struct(gen, item);
    } else if item.kind == ITEM_ENUM {
        generate_enum(gen, item);
    } else if item.kind == ITEM_CONST {
        generate_const(gen, item);
    } else if item.kind == ITEM_STATIC {
        generate_static(gen, item);
    }
    // TODO: Handle other item types
}

fn generate_function_declaration(gen: &mut CodeGen, item: &Item) {
    emit(gen, c_type_string(item.fn_return_type));
    emit(gen, " ");
    emit(gen, mangle_name(item.name));
    emit(gen, "(");
    
    if item.fn_param_count == 0 {
        emit(gen, "void");
    } else {
        let mut i = 0;
        while i < item.fn_param_count {
            if i > 0 {
                emit(gen, ", ");
            }
            let param = item.fn_params[i];
            emit(gen, c_type_string(param.param_type));
            emit(gen, " ");
            if param.pattern.kind == PAT_IDENT {
                emit(gen, param.pattern.name);
            } else {
                emit(gen, string_concat("_p", int_to_string(i)));
            }
            i = i + 1;
        }
    }
    
    emit_line(gen, ");");
}

fn generate_function(gen: &mut CodeGen, item: &Item) {
    // Generate signature
    emit(gen, c_type_string(item.fn_return_type));
    emit(gen, " ");
    emit(gen, mangle_name(item.name));
    emit(gen, "(");
    
    if item.fn_param_count == 0 {
        emit(gen, "void");
    } else {
        let mut i = 0;
        while i < item.fn_param_count {
            if i > 0 {
                emit(gen, ", ");
            }
            let param = item.fn_params[i];
            emit(gen, c_type_string(param.param_type));
            emit(gen, " ");
            if param.pattern.kind == PAT_IDENT {
                emit(gen, param.pattern.name);
            } else {
                emit(gen, string_concat("_p", int_to_string(i)));
            }
            i = i + 1;
        }
    }
    
    emit_line(gen, ") {");
    indent(gen);
    
    // Generate body
    let _ = generate_expr(gen, &item.fn_body);
    
    // Add implicit return for void functions
    if is_unit_type(item.fn_return_type) {
        emit_line(gen, "return;");
    }
    
    dedent(gen);
    emit_line(gen, "}");
    emit_newline(gen);
}

fn generate_struct(gen: &mut CodeGen, item: &Item) {
    emit(gen, "typedef struct ");
    emit(gen, mangle_name(item.name));
    emit_line(gen, " {");
    indent(gen);
    
    let mut i = 0;
    while i < item.struct_field_count {
        let field = item.struct_fields[i];
        emit(gen, c_type_string(field.field_type));
        emit(gen, " ");
        emit(gen, field.name);
        emit_line(gen, ";");
        i = i + 1;
    }
    
    dedent(gen);
    emit(gen, "} ");
    emit(gen, mangle_name(item.name));
    emit_line(gen, ";");
    emit_newline(gen);
}

fn generate_enum(gen: &mut CodeGen, item: &Item) {
    emit(gen, "typedef enum {");
    emit_newline(gen);
    indent(gen);
    
    let mut i = 0;
    while i < item.enum_variant_count {
        let variant = item.enum_variants[i];
        emit(gen, mangle_name(item.name));
        emit(gen, "_");
        emit(gen, variant.name);
        if i < item.enum_variant_count - 1 {
            emit(gen, ",");
        }
        emit_newline(gen);
        i = i + 1;
    }
    
    dedent(gen);
    emit(gen, "} ");
    emit(gen, mangle_name(item.name));
    emit_line(gen, ";");
    emit_newline(gen);
}

fn generate_const(gen: &mut CodeGen, item: &Item) {
    emit(gen, "const ");
    emit(gen, c_type_string(item.const_type));
    emit(gen, " ");
    emit(gen, mangle_name(item.name));
    emit(gen, " = ");
    let _ = generate_expr(gen, &item.const_value);
    emit_line(gen, ";");
    emit_newline(gen);
}

fn generate_static(gen: &mut CodeGen, item: &Item) {
    emit(gen, "static ");
    if item.is_mutable {
        // Mutable static
    } else {
        emit(gen, "const ");
    }
    emit(gen, c_type_string(item.const_type));
    emit(gen, " ");
    emit(gen, mangle_name(item.name));
    emit(gen, " = ");
    let _ = generate_expr(gen, &item.const_value);
    emit_line(gen, ";");
    emit_newline(gen);
}

// ============ Expression Generation ============

fn generate_expr(gen: &mut CodeGen, expr: &Expr) -> String {
    if expr.kind == EXPR_LITERAL {
        return generate_literal(gen, expr);
    } else if expr.kind == EXPR_IDENT {
        return generate_ident(gen, expr);
    } else if expr.kind == EXPR_BINARY {
        return generate_binary(gen, expr);
    } else if expr.kind == EXPR_UNARY {
        return generate_unary(gen, expr);
    } else if expr.kind == EXPR_CALL {
        return generate_call(gen, expr);
    } else if expr.kind == EXPR_INDEX {
        return generate_index(gen, expr);
    } else if expr.kind == EXPR_FIELD {
        return generate_field(gen, expr);
    } else if expr.kind == EXPR_ARRAY {
        return generate_array(gen, expr);
    } else if expr.kind == EXPR_IF {
        return generate_if(gen, expr);
    } else if expr.kind == EXPR_WHILE {
        return generate_while(gen, expr);
    } else if expr.kind == EXPR_FOR {
        return generate_for(gen, expr);
    } else if expr.kind == EXPR_BLOCK {
        return generate_block(gen, expr);
    } else if expr.kind == EXPR_ASSIGN {
        return generate_assign(gen, expr);
    } else if expr.kind == EXPR_RETURN {
        return generate_return(gen, expr);
    } else if expr.kind == EXPR_BREAK {
        return generate_break(gen, expr);
    } else if expr.kind == EXPR_CONTINUE {
        return generate_continue(gen, expr);
    } else if expr.kind == EXPR_MATCH {
        return generate_match(gen, expr);
    }
    
    return "/* unknown expression */";
}

fn generate_literal(gen: &mut CodeGen, expr: &Expr) -> String {
    if expr.literal_kind == LIT_INT {
        return int_to_string(expr.int_value);
    } else if expr.literal_kind == LIT_BOOL {
        if expr.bool_value {
            return "true";
        } else {
            return "false";
        }
    } else if expr.literal_kind == LIT_CHAR {
        return string_concat(string_concat("'", escape_char(expr.char_value)), "'");
    } else if expr.literal_kind == LIT_STRING {
        return string_concat("__pd_string_new(\"", string_concat(escape_string(expr.string_value), "\")"));
    }
    
    return "/* unknown literal */";
}

fn generate_ident(gen: &mut CodeGen, expr: &Expr) -> String {
    return mangle_name(expr.name);
}

fn generate_binary(gen: &mut CodeGen, expr: &Expr) -> String {
    let left = generate_expr(gen, &expr.left);
    let right = generate_expr(gen, &expr.right);
    
    // String concatenation special case
    if expr.binop == BINOP_ADD && is_string_type(expr.left.expr_type) {
        return string_concat(string_concat(string_concat("__pd_string_concat(", left), ", "), string_concat(right, ")"));
    }
    
    let op = binary_op_string(expr.binop);
    return string_concat(string_concat(string_concat(string_concat("(", left), " "), op), string_concat(" ", string_concat(right, ")")));
}

fn generate_unary(gen: &mut CodeGen, expr: &Expr) -> String {
    let operand = generate_expr(gen, &expr.operand);
    let op = unary_op_string(expr.unop);
    
    if expr.unop == UNOP_DEREF {
        return string_concat(string_concat("(*", operand), ")");
    } else {
        return string_concat(string_concat("(", op), string_concat(operand, ")"));
    }
}

fn generate_call(gen: &mut CodeGen, expr: &Expr) -> String {
    let callee = generate_expr(gen, &expr.callee);
    
    // Map built-in functions
    let mapped_name = map_builtin_function(callee);
    
    let mut result = string_concat(mapped_name, "(");
    
    let mut i = 0;
    while i < expr.arg_count {
        if i > 0 {
            result = string_concat(result, ", ");
        }
        result = string_concat(result, generate_expr(gen, &expr.args[i]));
        i = i + 1;
    }
    
    result = string_concat(result, ")");
    return result;
}

fn generate_index(gen: &mut CodeGen, expr: &Expr) -> String {
    let array = generate_expr(gen, &expr.array);
    let index = generate_expr(gen, &expr.index);
    return string_concat(string_concat(string_concat(array, "["), index), "]");
}

fn generate_field(gen: &mut CodeGen, expr: &Expr) -> String {
    let object = generate_expr(gen, &expr.object);
    return string_concat(string_concat(object, "."), expr.field_name);
}

fn generate_array(gen: &mut CodeGen, expr: &Expr) -> String {
    let temp = next_temp(gen);
    let elem_type = c_type_string(expr.elements[0].expr_type);
    
    emit(gen, elem_type);
    emit(gen, " ");
    emit(gen, temp);
    emit(gen, "[");
    emit(gen, int_to_string(expr.element_count));
    emit_line(gen, "] = {");
    indent(gen);
    
    let mut i = 0;
    while i < expr.element_count {
        if i > 0 {
            emit_line(gen, ",");
        }
        emit(gen, generate_expr(gen, &expr.elements[i]));
        i = i + 1;
    }
    
    emit_newline(gen);
    dedent(gen);
    emit_line(gen, "};");
    
    return temp;
}

fn generate_if(gen: &mut CodeGen, expr: &Expr) -> String {
    let result = next_temp(gen);
    
    if !is_unit_type(expr.expr_type) {
        emit(gen, c_type_string(expr.expr_type));
        emit(gen, " ");
        emit(gen, result);
        emit_line(gen, ";");
    }
    
    emit(gen, "if (");
    emit(gen, generate_expr(gen, &expr.condition));
    emit_line(gen, ") {");
    indent(gen);
    
    let then_val = generate_expr(gen, &expr.then_expr);
    if !is_unit_type(expr.expr_type) {
        emit(gen, result);
        emit(gen, " = ");
        emit(gen, then_val);
        emit_line(gen, ";");
    }
    
    dedent(gen);
    
    if expr.else_expr.kind != 0 {
        emit_line(gen, "} else {");
        indent(gen);
        
        let else_val = generate_expr(gen, &expr.else_expr);
        if !is_unit_type(expr.expr_type) {
            emit(gen, result);
            emit(gen, " = ");
            emit(gen, else_val);
            emit_line(gen, ";");
        }
        
        dedent(gen);
    }
    
    emit_line(gen, "}");
    
    if is_unit_type(expr.expr_type) {
        return "";
    } else {
        return result;
    }
}

fn generate_while(gen: &mut CodeGen, expr: &Expr) -> String {
    emit(gen, "while (");
    emit(gen, generate_expr(gen, &expr.condition));
    emit_line(gen, ") {");
    indent(gen);
    
    let _ = generate_expr(gen, &expr.body);
    
    dedent(gen);
    emit_line(gen, "}");
    
    return "";
}

fn generate_for(gen: &mut CodeGen, expr: &Expr) -> String {
    // Generate for loops as while loops with an iterator
    // This is a simplified version - proper implementation would handle iterators
    
    // For now, assume we're iterating over a range 0..n
    if expr.iterator.kind == EXPR_RANGE {
        let start = generate_expr(gen, &expr.iterator.range_start);
        let end = generate_expr(gen, &expr.iterator.range_end);
        
        // Create loop variable
        let loop_var = if expr.for_pattern.kind == PAT_IDENT {
            expr.for_pattern.name
        } else {
            next_temp(gen)
        };
        
        emit_line(gen, "{");
        indent(gen);
        
        // Initialize loop variable
        emit(gen, "long long ");
        emit(gen, loop_var);
        emit(gen, " = ");
        emit(gen, start);
        emit_line(gen, ";");
        
        // Generate while loop
        emit(gen, "while (");
        emit(gen, loop_var);
        emit(gen, " < ");
        emit(gen, end);
        emit_line(gen, ") {");
        indent(gen);
        
        // Generate body
        let _ = generate_expr(gen, &expr.body);
        
        // Increment loop variable
        emit(gen, loop_var);
        emit_line(gen, "++;");
        
        dedent(gen);
        emit_line(gen, "}");
        
        dedent(gen);
        emit_line(gen, "}");
    } else {
        // Fallback for other iterator types
        emit_line(gen, "/* for loop with non-range iterator not implemented */");
    }
    
    return "";
}

fn generate_block(gen: &mut CodeGen, expr: &Expr) -> String {
    emit_line(gen, "{");
    indent(gen);
    
    // Generate statements
    let mut i = 0;
    while i < expr.stmt_count {
        generate_stmt(gen, &expr.stmts[i]);
        i = i + 1;
    }
    
    // Generate final expression
    let result = if expr.final_expr.kind != 0 {
        generate_expr(gen, &expr.final_expr)
    } else {
        ""
    };
    
    dedent(gen);
    emit_line(gen, "}");
    
    return result;
}

fn generate_stmt(gen: &mut CodeGen, stmt: &Stmt) {
    if stmt.kind == STMT_LET {
        generate_let_stmt(gen, stmt);
    } else if stmt.kind == STMT_EXPR {
        let _ = generate_expr(gen, &stmt.expr);
        emit_line(gen, ";");
    } else if stmt.kind == STMT_SEMI {
        let _ = generate_expr(gen, &stmt.expr);
        emit_line(gen, ";");
    }
}

fn generate_let_stmt(gen: &mut CodeGen, stmt: &Stmt) {
    if stmt.pattern.kind == PAT_IDENT {
        emit(gen, c_type_string(stmt.let_type));
        emit(gen, " ");
        emit(gen, stmt.pattern.name);
        
        if stmt.init_expr.kind != 0 {
            emit(gen, " = ");
            emit(gen, generate_expr(gen, &stmt.init_expr));
        }
        
        emit_line(gen, ";");
    }
}

fn generate_assign(gen: &mut CodeGen, expr: &Expr) -> String {
    let left = generate_expr(gen, &expr.left);
    let right = generate_expr(gen, &expr.right);
    
    emit(gen, left);
    emit(gen, " = ");
    emit(gen, right);
    
    return "";
}

fn generate_return(gen: &mut CodeGen, expr: &Expr) -> String {
    emit(gen, "return");
    if expr.operand.kind != 0 {
        emit(gen, " ");
        emit(gen, generate_expr(gen, &expr.operand));
    }
    emit_line(gen, ";");
    return "";
}

fn generate_break(gen: &mut CodeGen, expr: &Expr) -> String {
    emit_line(gen, "break;");
    return "";
}

fn generate_continue(gen: &mut CodeGen, expr: &Expr) -> String {
    emit_line(gen, "continue;");
    return "";
}

fn generate_match(gen: &mut CodeGen, expr: &Expr) -> String {
    // Generate match as a series of if-else chains
    // This is a simplified version - a full implementation would handle patterns properly
    
    let result = next_temp(gen);
    let scrutinee = next_temp(gen);
    
    // Declare result variable if needed
    if !is_unit_type(expr.expr_type) {
        emit(gen, c_type_string(expr.expr_type));
        emit(gen, " ");
        emit(gen, result);
        emit_line(gen, ";");
    }
    
    // Store scrutinee value
    emit(gen, c_type_string(expr.match_expr.expr_type));
    emit(gen, " ");
    emit(gen, scrutinee);
    emit(gen, " = ");
    emit(gen, generate_expr(gen, &expr.match_expr));
    emit_line(gen, ";");
    
    // Generate if-else chain for arms
    let mut i = 0;
    while i < expr.arm_count {
        if i == 0 {
            emit(gen, "if (");
        } else {
            emit(gen, "} else if (");
        }
        
        // Generate pattern matching condition
        // For now, just handle simple patterns
        if expr.arms[i].pattern.kind == PAT_WILDCARD {
            emit(gen, "true");
        } else if expr.arms[i].pattern.kind == PAT_IDENT {
            // Binding pattern - always matches
            emit(gen, "true");
        } else {
            // TODO: Handle other pattern types
            emit(gen, "/* pattern not implemented */");
        }
        
        // Handle guard
        if expr.arms[i].guard.kind != 0 {
            emit(gen, " && ");
            emit(gen, generate_expr(gen, &expr.arms[i].guard));
        }
        
        emit_line(gen, ") {");
        indent(gen);
        
        // Handle pattern bindings
        if expr.arms[i].pattern.kind == PAT_IDENT {
            emit(gen, c_type_string(expr.match_expr.expr_type));
            emit(gen, " ");
            emit(gen, expr.arms[i].pattern.name);
            emit(gen, " = ");
            emit(gen, scrutinee);
            emit_line(gen, ";");
        }
        
        // Generate arm body
        let arm_val = generate_expr(gen, &expr.arms[i].body);
        if !is_unit_type(expr.expr_type) {
            emit(gen, result);
            emit(gen, " = ");
            emit(gen, arm_val);
            emit_line(gen, ";");
        }
        
        dedent(gen);
        
        i = i + 1;
    }
    
    emit_line(gen, "}");
    
    if is_unit_type(expr.expr_type) {
        return "";
    } else {
        return result;
    }
}

// ============ Helper Functions ============

fn c_type_string(ty: Type) -> String {
    if ty.kind == TYPE_KIND_PRIMITIVE {
        if ty.primitive == PRIM_I8 { return "char"; }
        if ty.primitive == PRIM_I16 { return "short"; }
        if ty.primitive == PRIM_I32 { return "int"; }
        if ty.primitive == PRIM_I64 { return "long long"; }
        if ty.primitive == PRIM_U8 { return "unsigned char"; }
        if ty.primitive == PRIM_U16 { return "unsigned short"; }
        if ty.primitive == PRIM_U32 { return "unsigned int"; }
        if ty.primitive == PRIM_U64 { return "unsigned long long"; }
        if ty.primitive == PRIM_F32 { return "float"; }
        if ty.primitive == PRIM_F64 { return "double"; }
        if ty.primitive == PRIM_BOOL { return "bool"; }
        if ty.primitive == PRIM_CHAR { return "char"; }
        if ty.primitive == PRIM_STRING { return "__pd_string"; }
        if ty.primitive == PRIM_UNIT { return "void"; }
    }
    
    if ty.kind == TYPE_KIND_ARRAY {
        // Arrays handled specially in declarations
        return c_type_string(ty.element_type);
    }
    
    if ty.kind == TYPE_KIND_POINTER {
        return string_concat(c_type_string(ty.pointee_type), "*");
    }
    
    if ty.kind == TYPE_KIND_REFERENCE {
        return string_concat(c_type_string(ty.pointee_type), "*");
    }
    
    if ty.kind == TYPE_KIND_STRUCT || ty.kind == TYPE_KIND_ENUM {
        return mangle_name(ty.name);
    }
    
    return "/* unknown type */";
}

fn mangle_name(name: String) -> String {
    // Special case for main
    if string_eq(name, "main") {
        return "main";
    }
    
    // For now, just prefix with __pd_
    return string_concat("__pd_", name);
}

fn map_builtin_function(name: String) -> String {
    if string_eq(name, "__pd_print") {
        return "__pd_print";
    }
    if string_eq(name, "__pd_print_int") {
        return "__pd_print_int";
    }
    if string_eq(name, "__pd_string_len") {
        return "__pd_string_len";
    }
    if string_eq(name, "__pd_string_concat") {
        return "__pd_string_concat";
    }
    if string_eq(name, "__pd_string_char_at") {
        return "__pd_string_char_at";
    }
    if string_eq(name, "__pd_string_from_char") {
        return "__pd_string_from_char";
    }
    if string_eq(name, "__pd_int_to_string") {
        return "__pd_int_to_string";
    }
    return name;
}

fn binary_op_string(op: i64) -> String {
    if op == BINOP_ADD { return "+"; }
    if op == BINOP_SUB { return "-"; }
    if op == BINOP_MUL { return "*"; }
    if op == BINOP_DIV { return "/"; }
    if op == BINOP_REM { return "%"; }
    if op == BINOP_AND { return "&"; }
    if op == BINOP_OR { return "|"; }
    if op == BINOP_XOR { return "^"; }
    if op == BINOP_SHL { return "<<"; }
    if op == BINOP_SHR { return ">>"; }
    if op == BINOP_EQ { return "=="; }
    if op == BINOP_NE { return "!="; }
    if op == BINOP_LT { return "<"; }
    if op == BINOP_GT { return ">"; }
    if op == BINOP_LE { return "<="; }
    if op == BINOP_GE { return ">="; }
    if op == BINOP_LOGICAL_AND { return "&&"; }
    if op == BINOP_LOGICAL_OR { return "||"; }
    return "?";
}

fn unary_op_string(op: i64) -> String {
    if op == UNOP_NEG { return "-"; }
    if op == UNOP_NOT { return "!"; }
    if op == UNOP_BITNOT { return "~"; }
    if op == UNOP_DEREF { return "*"; }
    return "?";
}

fn escape_string(s: String) -> String {
    // TODO: Implement proper string escaping
    return s;
}

fn escape_char(ch: i64) -> String {
    if ch == 10 { return "\\n"; }
    if ch == 13 { return "\\r"; }
    if ch == 9 { return "\\t"; }
    if ch == 0 { return "\\0"; }
    if ch == 92 { return "\\\\"; }
    if ch == 39 { return "\\'"; }
    return string_from_char(ch);
}

// ============ Test Function ============

fn test_codegen() {
    let input = "fn main() {
    let x = 42;
    let y = x + 10;
    let msg = \"Result: \";
    print(string_concat(msg, int_to_string(y)));
}";

    // First tokenize
    let mut lexer = create_lexer(input);
    
    // Then parse
    let mut parser = create_parser(lexer.tokens, lexer.token_count);
    let mut program = parse_program(&mut parser);
    
    // Type check
    let mut ctx = create_type_context();
    typecheck_program(&mut ctx, &mut program);
    
    // Generate code
    let mut gen = create_codegen();
    generate_program(&mut gen, &program);
    
    print("=== Code Generator Test ===");
    print("Generated C code:");
    print("------------------");
    print(gen.output);
}