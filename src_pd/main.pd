// Palladium Self-Hosting Compiler - Main Driver
// Entry point for the Palladium compiler written in Palladium

// ============ File I/O Functions (Runtime) ============

// These would be provided by the runtime
fn read_file(path: String) -> String {
    // Placeholder - actual implementation would read from file
    return "fn main() { print(\"Hello from Palladium!\"); }";
}

fn write_file(path: String, content: String) {
    // Placeholder - actual implementation would write to file
    print(string_concat("Writing to file: ", path));
    print(content);
}

// ============ Compiler Driver ============

fn compile_file(input_path: String, output_path: String) -> bool {
    print(string_concat("Compiling: ", input_path));
    
    // Read source file
    let source = read_file(input_path);
    
    // Create lexer and tokenize
    print("Phase 1: Lexical Analysis");
    let mut lexer = create_lexer(source);
    tokenize(&mut lexer);
    
    if lexer.token_count == 0 {
        print("Error: No tokens found");
        return false;
    }
    
    print(string_concat("  Tokens: ", int_to_string(lexer.token_count)));
    
    // Parse tokens into AST
    print("Phase 2: Parsing");
    let mut parser = create_parser(lexer.tokens, lexer.token_count);
    let mut program = parse_program(&mut parser);
    
    if parser.error_count > 0 {
        print("Parse errors:");
        let mut i = 0;
        while i < parser.error_count {
            print(string_concat("  ", parser.errors[i]));
            i = i + 1;
        }
        return false;
    }
    
    print(string_concat("  Items: ", int_to_string(program.item_count)));
    
    // Type check the AST
    print("Phase 3: Type Checking");
    let mut type_ctx = create_type_context();
    typecheck_program(&mut type_ctx, &mut program);
    
    if type_ctx.error_count > 0 {
        print("Type errors:");
        let mut i = 0;
        while i < type_ctx.error_count {
            print(string_concat("  ", type_ctx.errors[i]));
            i = i + 1;
        }
        return false;
    }
    
    print("  Type check passed");
    
    // Generate C code
    print("Phase 4: Code Generation");
    let mut codegen = create_codegen();
    generate_program(&mut codegen, &program);
    
    // Write output
    write_file(output_path, codegen.output);
    print(string_concat("Output written to: ", output_path));
    
    return true;
}

// ============ Command Line Interface ============

fn print_usage() {
    print("Palladium Compiler v0.1.0");
    print("Usage: pdc <input.pd> [-o <output.c>]");
    print("");
    print("Options:");
    print("  -o <file>    Output file (default: <input>.c)");
    print("  -h, --help   Show this help message");
    print("  -v, --version Show version information");
}

fn print_version() {
    print("Palladium Compiler v0.1.0");
    print("Self-hosting compiler for the Palladium programming language");
    print("Written in 100% Palladium!");
}

// ============ Main Entry Point ============

fn main() {
    // For now, compile a test program
    print("=== Palladium Self-Hosting Compiler ===");
    print("");
    
    // Test the compiler pipeline
    let test_program = "
fn factorial(n: i64) -> i64 {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

fn main() {
    let n = 5;
    let result = factorial(n);
    print(string_concat(\"Factorial of 5 is: \", int_to_string(result)));
}";

    // Create a full compilation
    print("Compiling test program...");
    print("------------------------");
    
    // Lexical analysis
    let mut lexer = create_lexer(test_program);
    tokenize(&mut lexer);
    print(string_concat("Tokens: ", int_to_string(lexer.token_count)));
    
    // Parsing
    let mut parser = create_parser(lexer.tokens, lexer.token_count);
    let mut program = parse_program(&mut parser);
    
    if parser.error_count > 0 {
        print("Parse errors found:");
        let mut i = 0;
        while i < parser.error_count {
            print(parser.errors[i]);
            i = i + 1;
        }
        return;
    }
    
    print(string_concat("Parsed items: ", int_to_string(program.item_count)));
    
    // Type checking
    let mut type_ctx = create_type_context();
    typecheck_program(&mut type_ctx, &mut program);
    
    if type_ctx.error_count > 0 {
        print("Type errors found:");
        let mut i = 0;
        while i < type_ctx.error_count {
            print(type_ctx.errors[i]);
            i = i + 1;
        }
        return;
    }
    
    print("Type check passed!");
    
    // Code generation
    let mut codegen = create_codegen();
    generate_program(&mut codegen, &program);
    
    print("");
    print("Generated C code:");
    print("=================");
    print(codegen.output);
    
    print("");
    print("Compilation successful!");
    print("");
    print("The Palladium self-hosting compiler is working!");
}