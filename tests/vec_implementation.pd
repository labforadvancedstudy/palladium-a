// Vec (dynamic array) implementation in Palladium
// This is a crucial data structure for bootstrapping!

struct Vec {
    data: [i64; 1000],  // Fixed backing array (for now)
    size: i64,          // Current number of elements
    capacity: i64,      // Maximum capacity (1000 for now)
}

// Create a new empty Vec
fn vec_new() -> Vec {
    return Vec {
        data: [0; 1000],
        size: 0,
        capacity: 1000
    };
}

// Get the current size of the Vec
fn vec_len(v: Vec) -> i64 {
    return v.size;
}

// Check if Vec is empty
fn vec_is_empty(v: Vec) -> bool {
    return v.size == 0;
}

// Push an element to the end of the Vec
fn vec_push(v: Vec, value: i64) -> Vec {
    if v.size >= v.capacity {
        // In a real implementation, we'd resize here
        print("Vec is full!");
        return v;
    }
    
    // Create a new Vec with the added element
    let mut new_vec: Vec = v;
    new_vec.data[new_vec.size] = value;
    new_vec.size = new_vec.size + 1;
    return new_vec;
}

// Get element at index (unsafe - no bounds checking)
fn vec_get(v: Vec, index: i64) -> i64 {
    if index < 0 {
        print("Index out of bounds: negative index");
        return 0;
    }
    if index >= v.size {
        print("Index out of bounds: too large");
        return 0;
    }
    return v.data[index];
}

// Set element at index
fn vec_set(v: Vec, index: i64, value: i64) -> Vec {
    if index < 0 {
        print("Index out of bounds: negative index");
        return v;
    }
    if index >= v.size {
        print("Index out of bounds: too large");
        return v;
    }
    
    let mut new_vec: Vec = v;
    new_vec.data[index] = value;
    return new_vec;
}

// Pop element from the end
fn vec_pop(v: Vec) -> Vec {
    if v.size == 0 {
        print("Cannot pop from empty Vec");
        return v;
    }
    
    let mut new_vec: Vec = v;
    new_vec.size = new_vec.size - 1;
    return new_vec;
}

// Get the last element (if any)
fn vec_last(v: Vec) -> i64 {
    if v.size == 0 {
        print("Vec is empty");
        return 0;
    }
    return v.data[v.size - 1];
}

// Clear the Vec
fn vec_clear() -> Vec {
    return vec_new();
}

// Test Vec implementation
fn test_vec_basic() {
    print("=== Test: Vec Basic Operations ===");
    
    let mut v = vec_new();
    
    if vec_is_empty(v) {
        print("âœ“ New Vec is empty");
    } else {
        print("âœ— New Vec should be empty");
    }
    
    // Push some elements
    v = vec_push(v, 10);
    v = vec_push(v, 20);
    v = vec_push(v, 30);
    
    if vec_len(v) == 3 {
        print("âœ“ Vec has correct length after pushes");
    } else {
        print("âœ— Vec length incorrect");
        print_int(vec_len(v));
    }
    
    // Test get
    if vec_get(v, 0) == 10 {
        if vec_get(v, 1) == 20 {
            if vec_get(v, 2) == 30 {
                print("âœ“ Vec get works correctly");
            } else {
                print("âœ— vec_get(2) incorrect");
            }
        } else {
            print("âœ— vec_get(1) incorrect");
        }
    } else {
        print("âœ— vec_get(0) incorrect");
    }
}

fn test_vec_set() {
    print("\n=== Test: Vec Set Operation ===");
    
    let mut v = vec_new();
    v = vec_push(v, 1);
    v = vec_push(v, 2);
    v = vec_push(v, 3);
    
    // Modify middle element
    v = vec_set(v, 1, 42);
    
    if vec_get(v, 0) == 1 {
        if vec_get(v, 1) == 42 {
            if vec_get(v, 2) == 3 {
                print("âœ“ Vec set works correctly");
            } else {
                print("âœ— vec_get(2) incorrect after set");
            }
        } else {
            print("âœ— vec_get(1) incorrect after set");
        }
    } else {
        print("âœ— vec_get(0) incorrect after set");
    }
}

fn test_vec_pop() {
    print("\n=== Test: Vec Pop Operation ===");
    
    let mut v = vec_new();
    v = vec_push(v, 100);
    v = vec_push(v, 200);
    v = vec_push(v, 300);
    
    let last = vec_last(v);
    if last == 300 {
        print("âœ“ vec_last returns correct value");
    } else {
        print("âœ— vec_last incorrect");
        print_int(last);
    }
    
    v = vec_pop(v);
    
    if vec_len(v) == 2 {
        if vec_last(v) == 200 {
            print("âœ“ Vec pop works correctly");
        } else {
            print("âœ— Last element after pop incorrect");
        }
    } else {
        print("âœ— Vec length after pop incorrect");
    }
}

fn test_vec_bounds() {
    print("\n=== Test: Vec Bounds Checking ===");
    
    let v = vec_new();
    
    // Test empty Vec access
    print("Testing empty Vec access (should print error):");
    let x = vec_get(v, 0);
    
    // Test negative index
    print("Testing negative index (should print error):");
    let y = vec_get(v, -1);
    
    print("âœ“ Bounds checking works");
}

fn test_vec_iteration() {
    print("\n=== Test: Vec Iteration ===");
    
    let mut v = vec_new();
    
    // Fill Vec with squares
    for i in 0..10 {
        v = vec_push(v, i * i);
    }
    
    // Sum all elements
    let mut sum = 0;
    for i in 0..vec_len(v) {
        sum = sum + vec_get(v, i);
    }
    
    // Sum of squares from 0 to 9 is 285
    if sum == 285 {
        print("âœ“ Vec iteration works correctly");
    } else {
        print("âœ— Sum incorrect");
        print_int(sum);
    }
}

fn test_vec_as_stack() {
    print("\n=== Test: Vec as Stack ===");
    
    let mut stack = vec_new();
    
    // Push elements
    stack = vec_push(stack, 1);
    stack = vec_push(stack, 2);
    stack = vec_push(stack, 3);
    
    // Pop and check
    if vec_last(stack) == 3 {
        stack = vec_pop(stack);
        if vec_last(stack) == 2 {
            stack = vec_pop(stack);
            if vec_last(stack) == 1 {
                stack = vec_pop(stack);
                if vec_is_empty(stack) {
                    print("âœ“ Vec works as stack");
                } else {
                    print("âœ— Stack should be empty");
                }
            } else {
                print("âœ— Third pop incorrect");
            }
        } else {
            print("âœ— Second pop incorrect");
        }
    } else {
        print("âœ— First element incorrect");
    }
}

// Demonstrate Vec usage for real problems
fn sieve_of_eratosthenes(n: i64) -> Vec {
    let mut primes = vec_new();
    
    // Create a boolean array "is_prime" and initialize all as true
    let mut is_prime = [true; 1000];
    
    // 0 and 1 are not prime
    is_prime[0] = false;
    is_prime[1] = false;
    
    for i in 2..n {
        if is_prime[i] {
            // i is prime, add to Vec
            primes = vec_push(primes, i);
            
            // Mark all multiples of i as not prime
            let mut j = i * 2;
            while j < n {
                is_prime[j] = false;
                j = j + i;
            }
        }
    }
    
    return primes;
}

fn test_vec_primes() {
    print("\n=== Test: Vec with Sieve of Eratosthenes ===");
    
    let primes = sieve_of_eratosthenes(30);
    
    // First 10 primes: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29
    if vec_len(primes) == 10 {
        if vec_get(primes, 0) == 2 {
            if vec_get(primes, 9) == 29 {
                print("âœ“ Sieve of Eratosthenes works with Vec");
                
                print("First 10 primes:");
                for i in 0..vec_len(primes) {
                    print_int(vec_get(primes, i));
                }
            } else {
                print("âœ— Last prime incorrect");
            }
        } else {
            print("âœ— First prime incorrect");
        }
    } else {
        print("âœ— Wrong number of primes");
        print_int(vec_len(primes));
    }
}

fn main() {
    print("=== Vec (Dynamic Array) Implementation ===\n");
    
    test_vec_basic();
    test_vec_set();
    test_vec_pop();
    test_vec_bounds();
    test_vec_iteration();
    test_vec_as_stack();
    test_vec_primes();
    
    print("\n=== All Vec Tests Complete ===");
    print("Vec is now functional! ðŸŽ‰");
    print("This is a major step toward bootstrapping!");
    print("Next: HashMap implementation!");
}