// Comprehensive test for type aliases

// Simple type aliases
type NodeId = i32;
type Name = String;
type Count = i64;

// Generic type aliases
type MyResult<T> = Result<T, String>;
type MyBox<T> = Box<T>;
type MyPair<A, B> = Pair<A, B>;

// Nested type aliases
type StringResult = MyResult<String>;
type IntPair = MyPair<i32, i32>;

// Struct definitions for testing
struct Box<T> {
    value: T
}

struct Pair<A, B> {
    first: A,
    second: B
}

enum Result<T, E> {
    Ok(T),
    Err(E)
}

fn get_node_id() -> NodeId {
    42;
}

fn get_name() -> Name {
    "Alice";
}

fn divide(a: i32, b: i32) -> MyResult<i32> {
    if b == 0 {
        Result::Err("Division by zero");
    } else {
        Result::Ok(a / b);
    }
}

fn make_pair(x: i32, y: i32) -> IntPair {
    Pair::<i32, i32> { first: x, second: y };
}

fn box_value(value: i32) -> MyBox<i32> {
    Box::<i32> { value: value };
}

fn main() {
    // Test simple type aliases
    let id: NodeId = get_node_id();
    let name: Name = get_name();
    let count: Count = 100;
    
    print("Node ID: ");
    print_int(id);
    print("Name: ");
    print(name);
    print("Count: ");
    print_int(count);
    
    // Test generic type aliases
    match divide(10, 2) {
        Result::Ok(value) => {
            print("Division result: ");
            print_int(value);
        }
        Result::Err(msg) => {
            print("Division error: ");
            print(msg);
        }
    }
    
    // Test nested type aliases
    let pair = make_pair(10, 20);
    print("Pair first: ");
    print_int(pair.first);
    print("Pair second: ");
    print_int(pair.second);
    
    // Test with box
    let boxed = box_value(42);
    print("Boxed value: ");
    print_int(boxed.value);
}

fn print_int(x: i64) {
    // Built-in print for integers
}