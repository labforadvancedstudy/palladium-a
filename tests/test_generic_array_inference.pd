// Test case for generic array type inference issue

// Generic function that takes an array parameter
fn first<T>(arr: [T; 5]) -> T {
    return arr[0];
}

// Generic function that returns an array
fn make_array<T>(value: T) -> [T; 3] {
    return [value, value, value];
}

// Generic function with multiple type parameters
fn swap_arrays<T, U>(a: [T; 2], b: [U; 2]) -> [T; 2] {
    return a;
}

fn main() {
    // Test 1: Inferring T from array literal
    let numbers = [1, 2, 3, 4, 5];
    let first_num = first(numbers);  // Should infer T = i64
    print_int(first_num);
    
    // Test 2: Inferring T for array creation
    let arr = make_array(42);  // Should infer T = i64, return [i64; 3]
    print_int(arr[0]);
    
    // Test 3: Multiple type parameters with arrays
    let int_arr = [10, 20];
    let str_arr = ["hello", "world"];
    let result = swap_arrays(int_arr, str_arr);  // Should infer T = i64, U = String
    print_int(result[0]);
    
    // Test 4: Nested array inference
    let matrix = [[1, 2], [3, 4], [5, 6]];
    // This would require inferring T = [i64; 2] if we had a generic function for it
    
    print("Generic array inference tests complete!");
}