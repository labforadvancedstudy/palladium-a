// Edge cases for exhaustiveness checking

enum SimpleEnum {
    A,
    B,
    C,
}

enum DataEnum {
    Empty,
    Single(i32),
    Pair(i32, i32),
}

// Test 1: All variants explicitly matched
fn test_all_explicit() {
    let e = SimpleEnum::A;
    match e {
        SimpleEnum::A => print("A"),
        SimpleEnum::B => print("B"),
        SimpleEnum::C => print("C"),
    }
}

// Test 2: Wildcard at end makes it exhaustive
fn test_wildcard_at_end() {
    let e = SimpleEnum::A;
    match e {
        SimpleEnum::A => print("A"),
        _ => print("Not A"),
    }
}

// Test 3: Variable binding is exhaustive
fn test_variable_binding() {
    let e = SimpleEnum::A;
    match e {
        x => print("Got something"),
    }
}

// Test 4: Data enum with all variants
fn test_data_enum_exhaustive() {
    let d = DataEnum::Empty;
    match d {
        DataEnum::Empty => print("Empty"),
        DataEnum::Single(n) => {
            print("Single: ");
            print_int(n);
        }
        DataEnum::Pair(x, y) => {
            print("Pair: ");
            print_int(x);
            print(", ");
            print_int(y);
        }
    }
}

// Test 5: Mix of specific patterns and wildcard
fn test_mixed_patterns() {
    let d = DataEnum::Empty;
    match d {
        DataEnum::Empty => print("Empty"),
        DataEnum::Single(n) => {
            print("Single: ");
            print_int(n);
        }
        _ => print("Something else"),
    }
}

fn main() {
    test_all_explicit();
    test_wildcard_at_end();
    test_variable_binding();
    test_data_enum_exhaustive();
    test_mixed_patterns();
}