// Test that array literal type inference now works for all types

struct Point {
    x: i64,
    y: i64,
}

struct Color {
    r: i64,
    g: i64,  
    b: i64,
}

fn main() {
    print("=== Array Literal Type Inference Fixed! ===\n");
    
    // Test 1: Integer arrays (already worked)
    let nums = [1, 2, 3, 4, 5];
    print("✓ Integer array: nums[0] =");
    print_int(nums[0]);
    
    // Test 2: Boolean arrays (already worked)
    let bools = [true, false, true];
    if bools[0] {
        print("✓ Boolean array: bools[0] = true");
    }
    
    // Test 3: Struct arrays (NOW WORKS!)
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 30, y: 40 };
    let p3 = Point { x: 50, y: 60 };
    
    // This now works without type annotation!
    let points = [p1, p2, p3];
    print("✓ Struct array WITHOUT type annotation!");
    print("  points[0].x =");
    print_int(points[0].x);
    
    // Test 4: Multiple struct types
    let c1 = Color { r: 255, g: 0, b: 0 };
    let c2 = Color { r: 0, g: 255, b: 0 };
    
    let colors = [c1, c2];  // Infers Color array
    print("✓ Different struct type array works!");
    print("  colors[0].r =");
    print_int(colors[0].r);
    
    // Test 5: Array repeat with structs
    let origin = Point { x: 0, y: 0 };
    let origins: [Point; 3] = [origin; 3];  // Still needs annotation for repeat
    print("✓ Array repeat still needs annotation");
    print("  origins[2].x =");
    print_int(origins[2].x);
    
    print("\n=== Success! ===");
    print("Array literal type inference now works for structs!");
}