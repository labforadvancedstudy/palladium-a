// Comprehensive tests for Palladium bootstrap components
// Tests lexer, parser, and AST representation

// Test helper - check if two strings are equal
fn assert_eq_str(actual: String, expected: String, test_name: String) {
    if string_eq(actual, expected) {
        print(string_concat("✓ ", test_name));
    } else {
        print(string_concat("✗ ", test_name));
        print(string_concat("  Expected: ", expected));
        print(string_concat("  Got:      ", actual));
    }
}

// Test helper - check if two integers are equal
fn assert_eq_int(actual: i64, expected: i64, test_name: String) {
    if actual == expected {
        print(string_concat("✓ ", test_name));
    } else {
        print(string_concat("✗ ", test_name));
        print(string_concat("  Expected: ", string_from_char(48 + expected)));
        print(string_concat("  Got:      ", string_from_char(48 + actual)));
    }
}

// Test the lexer components
fn test_lexer_utils() {
    print("\n=== Testing Lexer Utilities ===");
    
    // Test is_letter
    fn is_letter_test(c: i64) -> bool {
        if c >= 65 {
            if c <= 90 {
                return true;
            }
        }
        if c >= 97 {
            if c <= 122 {
                return true;
            }
        }
        if c == 95 {
            return true;
        }
        return false;
    }
    
    // Test cases
    let is_a = is_letter_test(97);  // 'a'
    let is_Z = is_letter_test(90);  // 'Z'
    let is_underscore = is_letter_test(95);  // '_'
    let is_digit = is_letter_test(48);  // '0' - should be false
    
    if is_a {
        print("✓ is_letter recognizes 'a'");
    } else {
        print("✗ is_letter failed for 'a'");
    }
    
    if is_Z {
        print("✓ is_letter recognizes 'Z'");
    } else {
        print("✗ is_letter failed for 'Z'");
    }
    
    if is_underscore {
        print("✓ is_letter recognizes '_'");
    } else {
        print("✗ is_letter failed for '_'");
    }
    
    if is_digit == false {
        print("✓ is_letter correctly rejects '0'");
    } else {
        print("✗ is_letter incorrectly accepts '0'");
    }
}

// Test string utilities
fn test_string_utils() {
    print("\n=== Testing String Utilities ===");
    
    // Test string_len
    let s1 = "Hello";
    let len1 = string_len(s1);
    assert_eq_int(len1, 5, "string_len('Hello')");
    
    // Test string_concat
    let s2 = "World";
    let s3 = string_concat(s1, s2);
    assert_eq_str(s3, "HelloWorld", "string_concat");
    
    // Test string_substring
    let sub = string_substring(s3, 0, 5);
    assert_eq_str(sub, "Hello", "string_substring(0, 5)");
    
    // Test string_char_at
    let ch = string_char_at("ABC", 1);
    assert_eq_int(ch, 66, "string_char_at (B=66)");
    
    // Test string_from_char
    let char_str = string_from_char(65);
    assert_eq_str(char_str, "A", "string_from_char(65)");
}

// Test Option types
fn test_option_types() {
    print("\n=== Testing Option Types ===");
    
    // Create OptionInt enum for testing
    enum OptionInt {
        Some(i64),
        None,
    }
    
    fn option_int_is_some(opt: OptionInt) -> bool {
        match opt {
            OptionInt::Some(_) => true,
            OptionInt::None => false,
        }
    }
    
    let some_val = OptionInt::Some(42);
    let none_val = OptionInt::None;
    
    if option_int_is_some(some_val) {
        print("✓ Option::Some detected correctly");
    } else {
        print("✗ Option::Some detection failed");
    }
    
    if option_int_is_some(none_val) == false {
        print("✓ Option::None detected correctly");
    } else {
        print("✗ Option::None detection failed");
    }
}

// Test Result types
fn test_result_types() {
    print("\n=== Testing Result Types ===");
    
    // Create IntResult enum for testing
    enum IntResult {
        Ok(i64),
        Err(String),
    }
    
    fn result_is_ok(res: IntResult) -> bool {
        match res {
            IntResult::Ok(_) => true,
            IntResult::Err(_) => false,
        }
    }
    
    let ok_val = IntResult::Ok(100);
    let err_val = IntResult::Err("Error message");
    
    if result_is_ok(ok_val) {
        print("✓ Result::Ok detected correctly");
    } else {
        print("✗ Result::Ok detection failed");
    }
    
    if result_is_ok(err_val) == false {
        print("✓ Result::Err detected correctly");
    } else {
        print("✗ Result::Err detection failed");
    }
}

// Test array operations
fn test_arrays() {
    print("\n=== Testing Arrays ===");
    
    // Test array initialization with repeat syntax
    let zeros = [0; 5];
    
    // Test array indexing
    let arr = [10, 20, 30, 40, 50];
    
    assert_eq_int(arr[0], 10, "Array index 0");
    assert_eq_int(arr[2], 30, "Array index 2");
    assert_eq_int(arr[4], 50, "Array index 4");
    
    // Test array in loop
    let sum = 0;
    for i in 0..5 {
        sum = sum + arr[i];
    }
    assert_eq_int(sum, 150, "Array sum");
}

// Test pattern matching
fn test_pattern_matching() {
    print("\n=== Testing Pattern Matching ===");
    
    enum Color {
        Red,
        Green,
        Blue,
        RGB(i64, i64, i64),
    }
    
    fn color_name(c: Color) -> String {
        match c {
            Color::Red => "Red",
            Color::Green => "Green",
            Color::Blue => "Blue",
            Color::RGB(_, _, _) => "RGB",
        }
    }
    
    let c1 = Color::Red;
    let c2 = Color::RGB(255, 0, 0);
    
    assert_eq_str(color_name(c1), "Red", "Pattern match Red");
    assert_eq_str(color_name(c2), "RGB", "Pattern match RGB");
}

// Test control flow
fn test_control_flow() {
    print("\n=== Testing Control Flow ===");
    
    // Test for loop with break
    let mut count = 0;
    for i in 0..10 {
        if i == 5 {
            break;
        }
        count = count + 1;
    }
    assert_eq_int(count, 5, "For loop with break");
    
    // Test while loop with continue
    let mut i = 0;
    let mut sum = 0;
    while i < 10 {
        i = i + 1;
        if i % 2 == 0 {
            continue;
        }
        sum = sum + i;
    }
    assert_eq_int(sum, 25, "While loop with continue (1+3+5+7+9)");
}

// Main test runner
fn main() {
    print("=== Palladium Bootstrap Component Tests ===");
    print("Testing all bootstrap components...\n");
    
    test_string_utils();
    test_lexer_utils();
    test_option_types();
    test_result_types();
    test_arrays();
    test_pattern_matching();
    test_control_flow();
    
    print("\n=== All Tests Complete ===");
    print("Bootstrap components are working correctly!");
    print("Ready for the next phase of self-hosting!");
}