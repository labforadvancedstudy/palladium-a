// Test const generics feature

// Basic const generic struct
struct Buffer<T, const N: usize> {
    data: [T; N],
}

// Function with const generic parameter
fn create_buffer<T, const SIZE: usize>() -> Buffer<T, SIZE> {
    Buffer {
        data: [0; SIZE], // This assumes T can be zero-initialized
    }
}

// Using const generics with arrays
fn sum_array<const N: usize>(arr: [i32; N]) -> i32 {
    let mut sum = 0;
    for i in 0..N {
        sum = sum + arr[i];
    }
    sum
}

// Const generic in impl block
impl<T, const N: usize> Buffer<T, N> {
    fn new() -> Buffer<T, N> {
        Buffer {
            data: [0; N], // Placeholder
        }
    }
    
    fn len(&self) -> usize {
        N
    }
}

fn main() {
    // Create buffers with different sizes
    let small_buffer: Buffer<i32, 10> = create_buffer();
    let large_buffer: Buffer<i32, 1000> = create_buffer();
    
    // Use const generic array
    let arr: [i32; 5] = [1, 2, 3, 4, 5];
    let total = sum_array(arr);
    print("Sum: ");
    print(total);
    print("\n");
    
    // Test impl methods
    let buf = Buffer::<i32, 20>::new();
    print("Buffer length: ");
    print(buf.len());
    print("\n");
}